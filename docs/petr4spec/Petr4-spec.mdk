Title         : Formalization of P4's Type System
Title Footer  : &date;
Author        : Parisa Ataei, Harim Hahn, Ryan Doenges, Nate Foster
Affiliation   : Cornell University
Heading depth : 5
Cite Style    : numeric
BibTex        : False
Bib           : reference

Math Mode       : static
Pdf Latex       : xelatex
Math Latex Full : pdflatex

Document Class : [11pt]article

Package : mathtools
Package : fancyhdr
Package : mathpartir

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

.code: background-color=Gainsboro
.code2: background-color=LightCoral
.code3: background-color=Fuchsia

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 &source;&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4syntax {
  replace: "~ Begin P4SyntaxBlock&nl;\
                 &source;&nl;\
                 ~ End P4SyntaxBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4syntax {
  replace: "~ Begin P4SyntaxBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4SyntaxBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
infrule {
  replace: "~ Begin InfRuleBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #fffaf0;
  border-width: 0.5pt;
}
}

@if tex {
infrule {
  replace: "~ Begin InfRuleBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #fffaf0;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
infrulehelper {
  replace: "~ Begin InfRuleHelperBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleHelperBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #ECE1FB;
  border-width: 0.5pt;
}
}

@if tex {
infrulehelper {
  replace: "~ Begin InfRuleHelperBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleHelperBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #ECE1FB;
  border: solid;
  border-width: 0.5pt;
}
}


~Aligned : replace:"~Math&nl;\begin{aligned}&nl;&source;&nl;\end{aligned}&nl;~" 


[TITLE]


~ Begin Abstract
P4's type system as describe in P4 spec cannot answer some questions precisely, such as when is an implict cast being inserted, what types are equal, what type inference algorithm is used, etc.
On the other hand, the type system as implemented in p4c is not easy to understand since it is distributed among more than half a dozen passes and interspered with non-typing passes.
In this document, we present the formalization of the type system. More specifically, we break it down into a simple type checker and a type inference algorithm. The goal is to spell out all the details of P4's type system precisely. 
The target audience of this document is mainly language designers and compiler experts who work on P4. Additionally, it can be a good resource for practitioners who require a deep understanding of P4.
~ End Abstract

~ MathDefs
[INCLUDE="ops.tex"]
~


[TOC]

# Introduction { #sec-intro }

[issue-875]: https://github.com/p4lang/p4-spec/issues/875
[issue-1241]: https://github.com/p4lang/p4-spec/issues/1241
[issue-1242]: https://github.com/p4lang/p4-spec/issues/1242
[issue-884]: https://github.com/p4lang/p4-spec/issues/884
[issue-1062]: https://github.com/p4lang/p4-spec/issues/1062
[issue-1101]: https://github.com/p4lang/p4-spec/issues/1101

P4's type system as describe in P4 spec cannot answer some questions, such as when is
an implict cast being inserted, what types are equal, what type inference algorithm is
used, etc. Even worse it sometimes fails to answer the basic question of when does a
program type check. This is evident by the filed issues on P4 spec's GitHub repository
such as [issue #875][issue-875], [issue #1241][issue-1241], [issue #1242][issue-1242],
[issue #884][issue-884], [issue #1062][issue-1062], and [issue #1101][issue-1101].
The reason behind this failure is threefold. First, some of the definitions required to
have a complete type system is missing from the spec, for example, the definition of
type equality which is discussed in [issue #875][issue-875]. Second, some of the
definitions and explanations are ambiguous or inconsistent, for example, the description
of casting which is discussed in [issue #1241][issue-1241], [issue #1242][issue-1242],
etc. And finally, some are spread across multiple sections of the spec which makes
understanding them difficult, for example, in order to understand binary operations in
P4 one has to read 18 sections of the spec and gather information spread out in these 18
sections.

On the other hand, p4c implements a type system for P4 so it can answer some of the
questions that the spec cannot. Unfortunately, there are more than half a dozen typing
passes in p4c which are interspered with non-typing passes, as shown in the simplified
p4c's pipeline shown in Figure [#fig-p4c-pipeline].

~ Figure { #fig-p4c-pipeline; caption: "P4c compiler pipeline." }
![p4cpipeline]
~
[p4cpipeline]: figs/p4c/p4c-pipeline.png { width: 100%; page-align: forcehere }

This document defines P4's type system precisely. The type system is broken down to
multiple passes and is conducted over the  _surface itermediate representation (IR)_.
Figure [#fig-petr4-pipeline] illustrates the passes.

~ Figure { #fig-petr4-pipeline; caption: "P4 front-end pipeline." }
![petr4pipeline]
~
[petr4pipeline]: figs/petr4/petr4-pipeline.png { width: 20%; page-align: forcehere }

_Ellaboration_ is a pre-processing pass that generates fresh variable names for un-named
variables along with other pre-processing required for typing. 
_Inference_ conducts type inference, i.e., it infers the type for parts of the program
that miss typing annotations, and insertion of casts, i.e., to conver a program from one
type to another. Consequently, it generates
another program written in the surface IR. 
_Type checking_ is a simple type checking pass that states if a program is well-typed or
not. 

## Design Goals { #sec-design-goals }
The design goals of this type system are the following:

- **Simple representation**: the IR is designed to be as simple as possible and as close
to P4's surface syntax as possible. Still, at any point in the pipeline it has to be
able to be pretty printed to a valid P4 program. 
- **Well-defined type system**: the type system fully and precisely defines valid programs
in a way that is easy to reason about informally and formally.
- **Separation of concern**: the type system is broken up to multiple passes to make
each pass simpler and easier to understand. 

# Syntax { #sec-syntax }

A P4 program is parsed to the surface IR and can be represented in the surface IR. The
structure of this IR is deescribed in the form of an abstract syntax tree (AST). All
definitions of this specification use this abstract syntax.
For simplicity, the surface IR does not contain annotations and meta-information.

## Conventions { #sec-conventions }

We describe the various conventions that have been adopted in writing this document.

### Grammar Notation { #sec-grammar-notation }

The following conventions are adopted in defining the grammar rules for surface IR's abstract syntax:

- A _phrase_ is a part of the program. 
- Terminal symbols are writeen in sans-serif font or in symbolic form: $\boolTyp$, $\accept$, $\langle$, $\oplus$.
- Nonterminal symbols are written in italic font: $\exp$, $\stmt$.
- Each nonterminal symbol defines a new _syntactic category_.
- Production rules in grammar are written as $\synCat ::= \A_1 | \cdots | \A_n$. Each rule describes a syntactic category and has multiple _constructor case_s. For example, the rule here describes the syntactic category $\synCat$ and has $n$ cases.
- Each case of a syntactic category is accompanied with a pharse that describes the role of that case, as shown below. Such phrase is not part of the grammar and is solely used as a comment to clarify the grammar more.

~ Begin P4Syntax

|     |      |     |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|:~~~~|
| $\synCat$ | $::= $ | $\A_1$ | $\qquad \text{comment}$ |
|   | $\vert$ | $\A_2$ | $\qquad \text{comment}$|
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

- Large production rules may be split into multiple production rules. This is explicitly indicated by having ellipses at the beginning or/and end of a rule. For example, $\synCat ::= \cdots | \A_i | \cdots$.

### Auxiliary Notation { #sec-aux-notation-ast }

Additionally, the following notation is used to keep definitions concise:

- The notation $(a,b)$ is a pair where the first element is $a$ and the second element is $b$. For examaple, $(\tru, 3)$ is a pair of $\tru$ and $3$.
- The notation $a \rightarrow b$ denotes a function that has domain $a$ and co-domain $b$. Note that both $a$ and $b$ reperenst a (possibly different) type.
- For simplicity, a function also denotes a mapping.
- The notation $\A : \typ$ states that $\A$ has type $\typ$. For example, $\fls : \boolTyp$.
- The following production rule is a record that its $\field_i$ has type $\typ_i$.

~ Begin P4Syntax

|     |      |     |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|:~~~~|
| $r$ | $::= \{$ | $\field_1 : \typ_1$ |
|   |  | $\field_2 : \typ_2$ |
|   |  | $\cdots \}$ |
{ .booktable }

~ End P4Syntax

- The notation $r.\field$ denotes the contents of the $\field$ component of $r$.
- The notation $\with r {\VVal {\field_i}}$ is the same as record $r$ excpet that it updates the field $\field_i$ to $\VVal {\field_i}$.

### Metavariables { #sec-metavars }

_Metavariables_ are nonterminal symbols that sit in place of a specific kind of value which do not necessarily require a syntactic category associated to them such as boolean values. Throughout this specification, various metavariables are used and they are introduced in Table [#tab-metavars].

~ Center
| **metavariable**   |   **values represented** |
|:----------------:|:------------------|
| $\synCat$ | syntactic categories     |
| $\A$ | constructor case |
| $\name$ | strings representing names |
| $\typName$ | type names |
| $\typVar$ | type variables |
| $\field$ | field names |
| $\kind$ | function kinds |
| $\bool$ | booleans |
| $\str$ | strings |
| $\int$ | arbitrary length integer |
| $\width$ | width |

~

## Directions { #sec-ast-dir }

Directions are used for parameters and they determine whether the parameter is used as input, output, or both.

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dir$ | $::=$ | $\inDir$ | $\qquad \text{copy-in}$ |
|   | $\vert$ | $\out$ | $\qquad \text{copy-out}$ |
|   | $\vert$ | $\inout$ | $\qquad \text{copy-in-out}$ |
|   | $\vert$ | $\less$ | $\qquad \text{directionless}$ |
{ .booktable }

~ End P4Syntax

## Parameters { #sec-ast-prm }

- The syntactic category [$\exp$][#sec-ast-exp] defines expressions.
- When defining a parameter, its direction is optional. However, instead of using an optional type, we denote this by the case of $\less$.

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\prmDef$ | $::=$ | $\dir \, \typ \, \var$ | $\qquad \text{parameters}$ |
|   | $\vert$ | $\dir \, \typ \, \var = \exp$ | $\qquad \text{parameters with initializers}$ |
{ .booktable }
~ End P4Syntax

## Types { #sec-ast-type }


The surface IR has a signle syntactic category for types, however, this syntactic category represents three kinds of types:

- **Surface types**: types that are directly written by a programmer in a P4 program.
- **Declared types**: types that are declared by a P4 program.
- **Synthesized types**: types that are synthesized by a P4 program. 

### Surface Types { #sec-ast-surface-type }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ $ | $::=$ | $\boolTyp$ | $\qquad \text{booleans}$ |
|   | $\vert$ | $\errTyp$ | $\qquad \text{errors}$ |
|   | $\vert$ | $\matchKindTyp$ | $\qquad \text{match kinds}$ |
|   | $\vert$ | $\integerTyp$ | $\qquad \text{infinite-precision integers}$ |
|   | $\vert$ | $\stringTyp$ | $\qquad \text{strings}$ |
|   | $\vert$ | $\intWidthTyp \exp$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidthTyp \exp$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\varbitTyp \exp$ | $\qquad \text{variable-width integers with a maximum width}$ |
|   | $\vert$ | $\typName$ | $\qquad \text{type names}$ |
|   | $\vert$ | $\spcTyp {\typName} {\typ}$ | $\qquad \text{specialized types}$ |
|   | $\vert$ | $\headerStackTyp {\typ} \exp$ | $\qquad \text{header stacks}$ |
|   | $\vert$ | $\tupleTyps {\typ}$ | $\qquad \text{tuples}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Declared Types { #sec-ast-dcl-type }

*todo: note if a list of args such as type parameters or types for tuples is empty, it will appear with a space instead of having $\langle \emp \rangle$*

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\headerTyps \typParam \field {\typ}$ | $\qquad \text{headers}$ |
|   | $\vert$ | $\headerUnionTyps \typParam \field {\typ}$ | $\qquad \text{header unions}$ |
|   | $\vert$ | $\structTyps \typParam \field {\typ}$ | $\qquad \text{structs}$ |
|   | $\vert$ | $\enumTypDef$ | $\qquad \text{serializable enums}$ |
|   | $\vert$ | $\enumTypNoTypDef$ | $\qquad \text{enums}$ |
|   | $\vert$ | $\parserTyp \typParam {\prmDef}$ | $\qquad \text{parsers}$ |
|   | $\vert$ | $\controlTyp \typParam {\prmDef}$ | $\qquad \text{controls}$ |
|   | $\vert$ | $\packageTyp \typParam {\prmDef}$ | $\qquad \text{packages}$ |
|   | $\vert$ | $\newTypeTyp \typName {\typ}$ | $\qquad \text{reference}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Synthesized Types { #sec-ast-synt-type }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\funcType \kind \typParam {\prmDef } {\typ}$ | $\qquad \text{functions}$ |
|   | $\vert$ | $\setTyp {\typ}$ | $\qquad \text{sets}$ |
|   | $\vert$ | $\externTyp \name$ | $\qquad \text{externs}$ |
|   | $\vert$ | $\actionTyp { { {\prmDef}}} { {\VVal {\prmDef}}}$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\constructorTyp \typParam {\prmDef} \typ$ | $\qquad \text{constructors}$ |
|   | $\vert$ | $\tableTyp \name$ | $\qquad \text{tables}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax


### Leftover Types { #sec-ast-leftover-type }

There are some types that do not fit into the surface, declared, or synthesized types. Such types are added individually to the type syntactic category.

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\voidTyp$ | $\qquad \text{void}$ |
|   | $\vert$ | $\typVar$ | $\qquad \text{type variables}$ |
|   | $\vert$ | $\dontcareTyp$ | $\qquad \text{don't care}$ |
|   | $\vert$ | $\notInstantiatedTyp$ | $\qquad \text{not instantiated}$ |

~ End P4Syntax

## Expressions { #sec-ast-exp }


~ Begin P4Syntax
**Unary operations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\unaryOp$ | $::=$ | $\intoOp !$ | $\qquad \text{logical negation}$ |
|   | $\vert$ | $\intoOp \bitComplement$ | $\qquad \text{bitwise complement}$ |
|   | $\vert$ | $\intoOp -$ | $\qquad \text{unary minus}$ |
{ .booktable }

**Binary operations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\binOp$ | $::=$ | $\intoOp{\&\&}$ | $\qquad \text{logical and}$ |
|   | $\vert$ | $\intoOp \logor $ | $\qquad \text{logical or}$ |
|   | $\vert$ | $\intoOp +$ | $\qquad \text{numerical addition}$ |
|   | $\vert$ | $\intoOp -$ | $\qquad \text{numerical subtraction}$ |
|   | $\vert$ | $\intoOp *$ | $\qquad \text{numerical multiplication}$ |
|   | $\vert$ | $\intoOp \div$ | $\qquad \text{numerical division}$ |
|   | $\vert$ | $\intoOp \mod$ | $\qquad \text{numerical modulo}$ |
|   | $\vert$ | $\intoOp{==}$ | $\qquad \text{equality check}$ |
|   | $\vert$ | $\intoOp{!=}$ | $\qquad \text{inequality check}$ |
|   | $\vert$ | $\intoOp \plusSat$ | $\qquad \text{saturating addition}$ |
|   | $\vert$ | $\intoOp \subSat$ | $\qquad \text{saturation subtraction}$ |
|   | $\vert$ | $\intoOp \bitAnd$ | $\qquad \text{bitwise and}$ |
|   | $\vert$ | $\intoOp \bitOr$ | $\qquad \text{bitwise or}$ |
|   | $\vert$ | $\intoOp \bitXor$ | $\qquad \text{bitwise xor}$ |
|   | $\vert$ | $\intoOp \concat$ | $\qquad \text{bitwise concatenation}$ |
|   | $\vert$ | $\intoOp \shiftL$ | $\qquad \text{shift left}$ |
|   | $\vert$ | $\intoOp \shiftR$ | $\qquad \text{shift right}$ |
|   | $\vert$ | $\intoOp <$ | $\qquad \text{less than}$ |
|   | $\vert$ | $\intoOp \leqOp$ | $\qquad \text{less than or equal}$ |
|   | $\vert$ | $\intoOp >$ | $\qquad \text{greater than}$ |
|   | $\vert$ | $\intoOp \geqOp$ | $\qquad \text{greater than or equal}$ |
{ .booktable }

**Arguments:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\arg$ | $::=$ | $\argexp$ | $\qquad \text{expression}$ |
|   | $\vert$ | $\argkv$ | $\qquad \text{key value}$ |
|   | $\vert$ | $\missingarg$ | $\qquad \text{missing}$ |
{ .booktable }

**Expressions:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\exp$ | $::=$ | $\bool$ | $\qquad \text{booleans}$ |
|   | $\vert$ | $\str$ | $\qquad \text{strings}$ |
|   | $\vert$ | $\int$ | $\qquad \text{integers}$ |
|   | $\vert$ | $\intWidth \int \width$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidth \int \width$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\name$ | $\qquad \text{names (variables)}$ |
|   | $\vert$ | $\arrayAccess {\exp_1} {\exp_2}$ | $\qquad \text{array accesses}$ |
|   | $\vert$ | $\bitStringAccess {\exp_1} {\exp_2} {\exp_3}$ | $\qquad \text{bitstring slices}$ |
|   | $\vert$ | $\list \exps$ | $\qquad \text{lists}$ |
|   | $\vert$ | $\records \exp$ | $\qquad \text{records}$ |
|   | $\vert$ | $\unaryOp \exp$ | $\qquad \text{unary operations}$ |
|   | $\vert$ | $\exp_1 \binOp \exp_2$ | $\qquad \text{binary operations}$ |
|   | $\vert$ | $\cast {\typ} \exp$ | $\qquad \text{casts}$ |
|   | $\vert$ | $\typMem \typName \field$ | $\qquad \text{type members}$ |
|   | $\vert$ | $\errMem \field$ | $\qquad \text{error members}$ |
|   | $\vert$ | $\expMem \exp \field$ | $\qquad \text{expression members}$ |
|   | $\vert$ | $\ternary {\exp_1} {\exp_2} {\exp_3}$ | $\qquad \text{conditionals}$ |
|   | $\vert$ | $\funcCall \exp {\typs} \args$ | $\qquad \text{function calls}$ |
|   | $\vert$ | $\instantiation {\typ} {\args}$ | $\qquad \text{anonymous instantiation}$ |
|   | $\vert$ | $\mask {\exp_1} {\exp_2}$ | $\qquad \text{bit masks}$ |
|   | $\vert$ | $\range {\exp_1} {\exp_2}$ | $\qquad \text{ranges}$ |
{ .booktable }

~ End P4Syntax

## Statements { #sec-ast-stmt }

~ Begin P4Syntax

**Labels:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\lbl$ | $::=$ | $\defLbl$ | $\qquad \text{default}$ |
|   | $\vert$ | $\str$ | $\qquad \text{string labels}$ |
{ .booktable }

**Switchs:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\switchCase$ | $::=$ | $\actionCase \stmt$ | $\qquad \text{labeled block}$ |
|   | $\vert$ | $\lbl$ | $\qquad \text{fall through with label}$ |
{ .booktable }

**Statements:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\stmt$ | $::=$ | $\methodCall \exp {\typ} \arg$ | $\qquad \text{method call}$ |
|   | $\vert$ | $\assign {\exp_1} {\exp_2}$ | $\qquad \text{assignment}$ |
|   | $\vert$ | $\dirApp {\typ}\arg$ | $\qquad \text{direct application}$ |
|   | $\vert$ | $\ifthen \exp \stmt$ | $\qquad \text{if then}$ |
|   | $\vert$ | $\ifthenelse \exp {\stmt_1} {\stmt_2}$ | $\qquad \text{if then else}$ |
|   | $\vert$ | $\block \stmt$ | $\qquad \text{sequencing}$ |
|   | $\vert$ | $\exit$ | $\qquad \text{exit}$ |
|   | $\vert$ | $\noop$ | $\qquad \text{noop}$ |
|   | $\vert$ | $\return \exp$ | $\qquad \text{return}$ |
|   | $\vert$ | $\retNothing$ | $\qquad \text{return nothing}$ |
|   | $\vert$ | $\switch \exp \switchCase$ | $\qquad \text{switch}$ |
|   | $\vert$ | $\constDcl {\typ }\var \exp$ | $\qquad \text{constants}$ |
|   | $\vert$ | $\inst {\typ}\arg \var \stmt$ | $\qquad \text{instantiations (initialized)}$ |
|   | $\vert$ | $\instNoBlock {\typ}\arg \var$ | $\qquad \text{instantiations (uninitialized)}$ |
|   | $\vert$ | $\varDclInit {\typ}\var \exp$ | $\qquad \text{local variables (initialized)}$ |
|   | $\vert$ | $\varDcl {\typ}\var$ | $\qquad \text{local variables (uninitialized)}$ |
{ .booktable }

~ End P4Syntax

## Declarations { #sec-ast-dcl }    

Various syntactic categories are needed to define declarations.

~ Begin P4Syntax

**Parser states:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\nxt$ | $::=$ | $\str$ | $\qquad \text{next state}$ |
|   | $\vert$ | $\accept$ | $\qquad \text{accept state}$|
|   | $\vert$ | $\reject$ | $\qquad \text{reject state}$|
| $\pmatch$ | $::=$ | $\defMatch$ | $\qquad \text{default match}$ |
|   | $\vert$ | $\dontcareMatch$ | $\qquad \text{don't care match}$ |
|   | $\vert$ | $\exp$ | $\qquad \text{expression match}$ |
| $\case$ | $::=$ | $\expandCase \pmatches \nxt$ | $\qquad \text{match cases for the next state}$ |
| $\parserTran$ | $::=$ | $\nxt$ | $\qquad \text{next state transition}$ |
|   | $\vert$ | $\slctTran \exp \pcases$ | $\qquad \text{select next state transition}$ |
| $\state$ | $::=$ | $\stateDef \var \stmt \parserTran$ | $\qquad \text{states}$ |
{ .booktable }

**Table properties:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\action$ | $::=$ | $\actionDef \var \arg$ | $\qquad \text{actions}$ |
| $\prop$ | $::=$ | $\key \exp \var$ | $\qquad \text{keys}$ |
|   | $\vert$ | $\action$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\entry \pmatch \action$ | $\qquad \text{entries}$ |
|   | $\vert$ | $\custom \bool \var \exp$ | $\qquad \text{custom property}$ |
{ .booktable }

**Methods:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\extMethod$ | $::=$ | $\constructor \var {\prmDef}$ | $\qquad \text{constructors}$ |
|   | $\vert$ | $\abstractMethod {\typ }\var \typVar {\prmDef}$ | $\qquad \text{abstract methods}$ |
|   | $\vert$ | $\methodDef {\typ}\var \typVar {\prmDef}$ | $\qquad \text{methods}$ |
{ .booktable }

~ End P4Syntax

Declarations can be divided into three groups:

- declaring types
- declaring objects and functions
- initializing, declaring, or instantiation variables/constants/objects

### Declaration of Types { #sec-ast-dcl-type }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\headerDcl \typName \typParam \field {\typ}$ | $\qquad \text{header types}$ |
|   | $\vert$ | $\headerUnionDcl \typName \typParam \field {\typ}$ | $\qquad \text{header union types}$ |
|   | $\vert$ | $\structDcl \typName \typParam \field {\typ}$ | $\qquad \text{struct types}$ |
|   | $\vert$ | $\errDcl \field$ | $\qquad \text{error types}$ |
|   | $\vert$ | $\matchkindDcl \field$ | $\qquad \text{match kind types}$ |
|   | $\vert$ | $\enumDcl \typName \field$ | $\qquad \text{enumerated types}$ |
|   | $\vert$ | $\serEnumDcl {\typ}\typName \field \exp$ | $\qquad \text{serializable enumerated types}$ |
|   | $\vert$ | $\typdefDcl  {\typ} \typName$ | $\qquad \text{type definitions}$ |
|   | $\vert$ | $\typdefDcl \dcl \typName$ | $\qquad \text{type definitions (declarations)}$ |
|   | $\vert$ | $\newtypeDcl  {\typ}\typName$ | $\qquad \text{generative type definitions}$ |
|   | $\vert$ | $\newtypeDcl  \dcl \typName$ | $\qquad \text{generative type definitions (declarations)}$ |
|   | $\vert$ | $\controlTypDcl \typName \typVar {\prmDef}$ | $\qquad \text{control types}$ |
|   | $\vert$ | $\parserTypDcl \typName \typVar {\prmDef}$ | $\qquad \text{parser types}$ |
|   | $\vert$ | $\packageTypDcl \typName \typVar {\prmDef}$ | $\qquad \text{package types}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Declaration of Objects/Functions { #sec-ast-dcl-obj }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\parserDcl \var \typVar { { {\prmDef}}} { {\VVal {\prmDef}}} \dcl \state$ | $\qquad \text{parsers}$ |
|   | $\vert$ | $\controlDcl \var \typVar { { {\prmDef}}} { {\VVal {\prmDef}}} \dcl \stmt$ | $\qquad \text{controls}$ |
|   | $\vert$ | $\funcDcl {\typ}\var \typVar {\prmDef} \stmt$ | $\qquad \text{functions}$ |
|   | $\vert$ | $\externFuncDcl {\typ}\var \typVar {\prmDef}$ | $\qquad \text{extern functions}$ |
|   | $\vert$ | $\actionDcl \var {\prmDef} \stmt$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\tableDcl \var \prop$ | $\qquad \text{tables}$ |
|   | $\vert$ | $\externObjDcl \var \typVar \extMethod$ | $\qquad \text{extern objects}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Declaration of Variables/Constants/Instantiations { #sec-ast-dcl-var }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\constDcl {\typ }\var \exp$ | $\qquad \text{constants}$ |
|   | $\vert$ | $\inst {\typ}\arg \var \stmt$ | $\qquad \text{instantiations (initialized)}$ |
|   | $\vert$ | $\instNoBlock {\typ}\arg \var$ | $\qquad \text{instantiations (uninitialized)}$ |
|   | $\vert$ | $\varDclInit {\typ}\var \exp$ | $\qquad \text{local variables (initialized)}$ |
|   | $\vert$ | $\varDcl {\typ}\var$ | $\qquad \text{local variables (uninitialized)}$ |
|   | $\vert$ | $\valSetDcl {\typ}\exp \var$ | $\qquad \text{parser value sets}$ |
{ .booktable }

~ End P4Syntax

## Programs { #sec-ast-prog }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\prog$ | $::=$ | $\dcls$ | $\qquad \text{list of declarations}$ |
{ .booktable }

~ End P4Syntax



# Type Checker { #sec-type-checker }

The type checker takes a program written in the surface IR and simply states if the program is syntactically _well-formed_, that is, if the program is structurally valid. In which case it returns the type of the program. Note that the type checker does not change the given program at all. It assumes all type inference and cast insertion has already been taken care of. 

## Conventions { #sec-conventions-type-checker }

[#web-assembly-link]: https://webassembly.github.io/spec/core/index.html

The type checker is defined by a type system over the abstract syntax of a program and all its parts. Thus, for each syntactic category of the surface IR, there is a typing judgement and a set of typing rules. For each syntactic category, the judgement form specifies the form that all typing rules for that syntactic category follow and the typing rules specify the constraints that apply to each case of the syntactic category. We adopt the approach used in [web assembly specification][#web-assembly-link] and describe all rules in two formats:

- In _informal notation_, describing the meaning in intuitive English format.
- In _formal notation_, describing the rule in mathematical form.

### Enviornments { #sec-env }

The type checker is defined over an _enviornment_, which collects relevant information about the (sub-)program and carries in-scope definitions. In particular, it carries the following definitions:

- Types (denoted by $\typEnv$): the list of mapping a type name to its type
- Type synonyms ($\typSynEnv$): the list of mapping a type name to another type name
- Type variables ($\typParEnv$): the list of mapping a type variable to its type
- Variables ($\varEnv$): the list of mapping a variable to its type and direction
- Constants ($\constEnv$): the list of mapping a constant name to its value
- Externs ($\externEnv$): the list of mapping an extern name to methods it provides
- Context ($\ctxt$): states the lexical context and scope of the sub-program such as _top-level_, _parser_, etc, denoted 


To be concrete, environements are all accumulated in one place and they are defined as the [record][#sec-aux-notation-ast] $\env$. 

~ Begin P4Syntax

**Context:**

|     |      |     |
|~~~~:|:~~~~:|:~~~~|
| $\ctxtTyp$ | $::=$ | $\cte$ | 
|  | $\vert$ | $\applyBlockCtxt$ |
|  | $\vert$ | $\actionCtxt$ |
|  | $\vert$ | $\tableActionCtxt$ |
|  | $\vert$ | $\funcCtxt \typ$ |
|  | $\vert$ | $\parserCtxt$ |
|  | $\vert$ | $\toplevel$ |
|  | $\vert$ | $\declLocalCtxt$ |
{ .booktable }

**Enviornment:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\env$ | $::= \{$ | $\typEnv :  \typName \rightarrow \typ$ | $\qquad \text{types}$ |
|   |  | $\typSynEnv : \typName \rightarrow \typName$ | $\qquad \text{type synonyms}$ | $\qquad \name \rightarrow \typName$ |
|   |  | $\typParEnv :  \typName \rightarrow \typ$ | $\qquad \text{type variables}$ | 
|   |  | $\varEnv :  \name \rightarrow (\typ, \dir)$ | $\qquad \text{variables}$ |
|   |  | $\constEnv :  \name \rightarrow \val$ | $\qquad \text{constants}$ | 
|   |  | $\externEnv :  \name \rightarrow \externmethod$ | $\qquad \text{externs}$ | 
|   |  | $\ctxt : \ctxtTyp\}$ | $\qquad \text{context}$ | 
{ .booktable }

~ End P4Syntax

###### - Accessing each enviornment can be done through field access of $\env$. For example, $\env.\typEnv$ gives access to the contents of type enviornment. However, for simpilicity and since the enviorment is global, we omit the $\env.$ part. So for example, $\typEnv$ is a shorthand for $\env.\typEnv$. { -; font-weight: "normal"; id: access-env; label: "access-env" }
###### - The notation $\lookupTypEnv \name$ looks up $\name$ in type enviornment $\typEnv$. Such notation is used for looking up in any of the enviornments. Note that $\typEnv$ stands for $\env . \typEnv$ in a lookup as well. Consequently, the notation $\env(\name)$ is meaningless since it does not state which enviornment field of $\env$ is being used for the lookup. { -; font-weight: "normal"; id: lookup-env; label: "lookup-env" }
###### - The notation $\insertToTypEnv \typName \typ $ extends the type environment with the new assignment of $\typ$ to $\typName$. This notation is used for extending any of the environments. { -; font-weight: "normal"; id: extend-env; label: "extend-env" }
###### - The notation $\insertToTypParEnv \typParam$ is a shorthand for $\insertToTypParEnv {\typParam = \notInstantiatedTyp}$ which extends the type parameter environment with the new parameter $\typParam$ that is not instantiated.  { -; font-weight: "normal"; id: extend-typ-par-env; label: "extend-typ-par-env" }
###### - The notation $\updateEnv {\VVal \typEnv}$ is short for $\updateEnv {\typEnv = \VVal \typEnv}$ which denotes the same environment as $\env$, except that the type environement $\typEnv$ has been replaced with type environment $\VVal \typEnv$. { -; font-weight: "normal"; id: update-env; label: "update-env" }
###### - The notation $\updateEnv {\insertToTypEnv \typName \typ}$ denotes the same environment as $\env$, except that the type environement $\typEnv$ has been extended with the assignment of $\typ$ to $\typName$. { -; font-weight: "normal"; id: update-env-extension; label: "update-env-extension" }
###### - The notation $\updateEnv {\VVal \typEnv, \VVal \varEnv, \cdots}$ denotes the same environment as $\env$, except that the environment $\typEnv, \varEnv, \cdots$ have been replaced with environments $\VVal \typEnv, \VVal \varEnv, \cdots$. { -; font-weight: "normal"; id: update-envs; label: "update-envs" }
###### - The notation $\emp$ denotes an empty environment. { -; font-weight: "normal"; id: emp-env; label: "emp-env" }

### Informal Notation { #sec-informal-notation }
The type checker is specified by rules for each syntactic category of the [surface IR's abstract syntax][#sec-syntax]. The rules states the constraint that have to hold for a phrase to type check. For [types abstract syntax][#sec-ast-type], the rules only state what such constraints are. However, for the rest of the abstract syntax, the rules additionally output the type of the phrase. The following conventions are adopted in stating these rules.

- A type phrase $\A$ "is well-formed"  if and only if all constraints expressed by the respective rules hold.
- A phrase $\A$ "type checks with type $\typ$" if and only if all constraints expressed by the respective rules hold. The type $\typ$ depends on what $\A$ is.
- The rules implicitly assume a given [enviornment][#sec-env] $\env$.
- In some cases, this environment is locally extended to enviornment $\VVal \env$ with extensions in one or more of the $\env$'s fields (enviornments). The formulation "under enviornment $\VVal \env$, ... statement ..." is adopted to express that the statement only holds under the extended enviornment $\VVal \env$.
- In some cases, this environment is globally extended to environment $\VVal \env$ with extensions in one or more of the $\env$'s fields. In these cases, the extended enviornment is an output of the rule. The formulation "under enviornment $\env$, ... statment ... updates the environment to $\VVal \env$" is adopted to express this global extension of the enviornment. 

### Formal Notation { #sec-formal-notation }

Conventionally, a typing rule is formally written as an inference rules. A rule follows the general form of:

~ Begin InfRule

  \inferrule
     { \mathit{premise}_1 \\
       \mathit{premise}_2 \\
       \cdots \\
        \mathit{premise}_n}
     { \mathit{conclusion} }
     \quad (\rn{RuleName})

~ End InfRule

Such a rule reads as an implication: if all the premises hold, the the conclusion holds. Some rules do not have any premises, such rules are _axioms_ that hold unconditionally. The premises can either be:

- predicates that return true or false, for example, $ n > 1$ or $\isInt \exp$. 
- assignments where the result of a function application is assigned to a variable that will be used in either other premises or the conclusion, for example, $\compileTimeEval \exp = \int$ evaluates the expression $\exp$ and assigns its value to $\int$.

The conclusion is a judgment which can take one of the following *form*s. All the rules for a syntactic category have the same judgment form and there is one respective rule for each constructor case of the syntactic category.

- $\env \vdash \A$ states that $\A$ is well-formed under the enviornment $\env$.
- $\env \vdash \A : \typ$ states that $\A$ type checks and it has the type $\typ$ under the enviornment $\env$.
- $\env \vdash \A : \typ \dashv \VVal \env$ states that $\A$ type checks, it has the type $\typ$ under the enviornment $\env$, and it outputs the extended enviornment $\VVal \env$.

If a rule does not use $\env$ in its constraints, we omit the enviornment from the conclusion, that is, it takes the form $\vdash \A$. Still, the enviornment is implicitly assumed by the rule.

The conclusion judgment itself is aslo a predicate that my hold or not. Such a judgment applied to a smaller phrase than the conclusion can also appear as a premise in a rule. *todo: have an example.*

*todo: add that rules are pattern matched so more specific cases are presented first and then more general. an algorithm/impl should follow this order if pattern matching or add a predicate to the more general case that removes the more specific one. think if you need to say this in informal notation somehow. example: ser enum well-formed. also state that if you limit the syn category to a specific case and others don't exist it will fails.*

In the rest of this section:

- First, we introduce the judgment form for type checking each of the syntactic categories of our surface IR.
- Then, we read the judgment form out load.
- And finally, we provide the rules for each case of a syntactic category in both the formal and informal form.

[#pierce]: https://www.cis.upenn.edu/~bcpierce/tapl/

Since this is a very brief introduction to type systems we refer an interested reader to [TPL by Benjamin C. Pierce][#pierce] for a detailed explanation of type systems with examples.

#### Auxiliary Formal Notation { #sec-aux-formal-notation }

The typing rule introduced in the [formal notation section][#sec-formal-notation] is a logical form used to describe any iduction. We provide the conclusion forms for type checking phrases of a P4 program, that is, declarations, statements, expressions, and types. However, the conclusion form can take lots of forms depending on its syntactic category and induction. For type checking a P4 program, we need some auxiliary conclusion forms:

- [Type equality][#sec-type-eq-type-checker]: has the form $\typEq {\typ_1} {\typ_2}$ and states that under the environment $\env$ types $\typ_1$ and $\typ_2$ are equal.
- [Casting types][#sec-casting-type-checker]: has the form $\allcastenv {\typ_1} {\typ_2} $ and states that under the environment $\env$ the type $\typ_1$ can be casted to the type $\typ_2$.

### Auxiliary Notation { #sec-aux-notation-type-checker }

[#p4-type-nesting-rules]: https://p4.org/p4-spec/docs/P4-16-v-1.2.3.html#sec-type-nesting

The following notations are used in the definitions of the rules in the rest of this section:

###### - $\compileTimeEval \exp$ evaluates the well-formed expression $\exp$ with the enviornment $\env$ at compile-time. { -; font-weight: "normal"; id: compileTimeEval; label: "compileTimeEval" }
###### - $\compTimeKnown \exp$ is a predicate that returns $\tru$ if expression $\exp$ can be evaluated at compile-time. However, if the expression $\exp$ is a specialized type, extern, package, control, or parser but we cannot evaluate it at compile-time, we still consider it known at compile-time. { -; font-weight: "normal"; id: compTimeKnown; label: "compTimeKnown" }
###### - $\overline {\A}$ is a list of zero or more $\A$. { -; font-weight: "normal"; id: overline; label: "overline" }
###### - The notation $f(\overline x) = \overline y$ applies the function $f$ that takes $x$ and returns $y$ (i.e., $f(x) = y$) to a list input $\overline x$ and returns a list output $\overline y$. We adopt the similar notation for applying a judgement to a list of phrases, that is, applying the judgement $\env \vdash \A : \typ$ to a list of phrases gives us the judgement: $\env \vdash \overline \A : \overline \typ$. Note that in this example the enviornment will not be extended so we do not need to pass it as a list. Applying a predicate to an empty list returns $\tru$ unless stated otherwise. { -; font-weight: "normal"; id: mapping; label: "mapping" }
*todo: add the distinction between map over = and not*
###### - $\isHeaderOrUnion \typ$ is a predicate that returns $\tru$ if $\typ$ is a header or header union. { -; font-weight: "normal"; id: isHeaderOrUnion; label: "is_header_or_union" }
###### - $\isValidNestedTyp \typ$ is a predicate that returns true if the type $\typ$ can have nested types and its nested types are legal based on [P4's spec type nesting rules][#p4-type-nesting-rules]. We state explicitly what types can be nested in another type when defining the rule for the outer type to be well-formed. { -; font-weight: "normal"; id: isValidNestedTyp; label: "is_valid_nestted" }
###### - $\distinct \fields$ is a predicate that returns $\tru$ if fields in $\fields$ are all distinct. { -; font-weight: "normal"; id: distinct; label: "are_distinct" }
###### - $\noFreeTypVar \typ$ is a predicate that returns $\tru$ if none of the type variables defined for the generic type $\typ$ are not free. { -; font-weight: "normal"; id: noFreeTypVar; label: "no_free_type_var" }
###### - $\isWidthInt \typ$ is a predicate that returns $\tru$ if the type $\typ$ is either $\intWidthTyp \exp$ or $\bitWidthTyp \exp$. { -; font-weight: "normal"; id: isWidthInt; label: "is_width_int" }
###### - $\isHeader \typ$ is a predicate that returns $\tru$ if the type $\typ$ is a header. { -; font-weight: "normal"; id: isHeader; label: "is_header" }
###### - $\isNumeric \exp \typ$ is a predicate that returns $\tru$ if one of the following holds: { -; font-weight: "normal"; id: isNumeric; label: "is_numeric" }

   * $\compTimeKnown \exp$ and $\typ = \integerTyp$
   * $\typ = \intWidthTyp \width$
   * $\typ = \bitWidthTyp \width$

###### - $\isNumOrEnum \typ$ is a predicate that returns $\tru$ if $\typ$ is one of the following checks if $\typ$ is one of the following: { -; font-weight: "normal"; id: isNumOrEnum; label: "is_num_or_enum" }

   * $\integerTyp$
   * $\intWidthTyp \width$ ```does this have to be width? it cannot be an expression? same for the below```
   * $\bitWidthTyp \width$
   * $\enumTypDef$ ```p4 spec only allows the underlying type to be int<w> or bit<w>```

###### - $\maskTypeIs {\typ_1} {\typ_2}$ is a function that determines the type of a mask expression based on the type of its two operands and it is defined for the following cases: { -; font-weight: "normal"; id: maskTypeIs; label: "mask_type" }

  + if $\typ_1 = \typ_2 = \bitWidthTyp \width$,
  then $\maskTypeIs {\typ_1} {\typ_2} = \bitWidthTyp \width$
  + if $\typ_1 = \bitWidthTyp \width, \typ_2 = \integerTyp$,
  then $\maskTypeIs {\typ_1} {\typ_2} = \integerTyp$
  + if $\typ_1 = \integerTyp, \typ_2 =  \bitWidthTyp \width$,
  then $\maskTypeIs {\typ_1} {\typ_2} = \bitWidthTyp \width$

###### - $\typHasEq \typ$ is a predicate that returns $\tru$ if $\typ$ is one of the followings (conceptually, the following types are the ones that checking equality of two expressions both with one of these types has been defined. Note that this is different from checking if two types are equal): { -; font-weight: "normal"; id: typHasEq; label: "has_equality" }

   * $\errTyp$
   * $\boolTyp$
   * $\bitWidthTyp \width$ ``todo: why not $\bitWidthTyp \exp$?``
   * $\intWidthTyp \width$
   * $\varbitTyp \width$
   * $\integerTyp$
   * $\enumTypDef$
   * $\enumTypNoTypDef$
   * $\headerTyps \typParam \field {\surfaceTyp}$
   * $\headerUnionTyps \typParam \field {\surfaceTyp}$
   * $\structTyps \typParam \field \typ$

###### - $\concatCond {\typ_1} {\typ_2}$ is a function that determines the type of a concatenation expression based on the type of its left operand: { -; font-weight: "normal"; id: concatCond; label: "concat_type" }

  + if $\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \bitWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \intWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \bitWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \intWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \intWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \intWidthTyp {\width_1 + \width_2}$

###### - $\nonNeg \exp$ is a predicate that returns $\tru$ if expression $\exp$ can be evaluated at compile-time and it is non-negative. { -; font-weight: "normal"; id: nonNeg; label: "is_nonneg_numeric" }

###### - $\shiftCond {\typ} {\exp}$ is a predicate that returns $\tru$ if one of the following holds: { -; font-weight: "normal"; id: shiftCond; label: "shift_condition" }

  + $\typ = \bitWidthTyp \width$
  + $\typ = \integerTyp$ and $\nonNeg \exp$ 

###### - $\ifIntComp \typ \exp$ is a predicate that returns $\tru$ unless the type $\typ$ is $\integerTyp$ and the expression $\exp$ is not compile-time-known. { -; font-weight: "normal"; id: ifIntComp; label: "if_int_is_compile_time_known" }

###### - $\valMatchTyp \exp \typ$ is a predicate that returns true if every single expression in $\exps$ is well-formed with type $\typ$. { -; font-weight: "normal"; id: valMatchTyp; label: "value_match_type" }


- $\isSurface \typ$ is a predicate that returns $\tru$ if type $\typ$ is one of the cases of [surface types][#sec-ast-surface-type].
- An underscore (that is, $\whatevs$) is used when we do not need to use some specific information returned to us in a rule. For example, $\mathit{getLength}(\A)= \whatevs$ takes the length of $\A$, however, it actually does not care what the length is. Instead it just cares if $\A$ is a structure that has length.


## Types { #sec-type-type-checker }

The type checker judgement for types has the form $\typWellFormed \typ$ and it reads "the type $\typ$ is well-formed under the enviornment $\env$".


### Boolean Type { #sec-bool-t }

Boolean types are always well-formed.

$\boolTyp$

- The boolean type is well-formed.

~ Begin InfRule

  \inferrule
     { }
     { \typWellFormedNoEnv \boolTyp }
     \quad (\boolT)

~ End InfRule

### Error Type { #sec-error-t }

Error types are always well-formed.

$\errTyp$

- The error type is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \errTyp}
     \quad (\errT)
~ End InfRule

### Match Kind Type { #sec-match-kind-t }

Match kind types are always well-formed.

$\matchKindTyp$ 

- The match kind is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \matchKindTyp}
     \quad (\matchKindT)
~ End InfRule

### Integer Type { #sec-integer-t }
Integer types are always well-formed.

$\integerTyp$

- The integer type is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \integerTyp }
     \quad (\intT)
~ End InfRule

### String Type { #sec-string-t }
String types are alway well-formed.

$\stringTyp$

- The string type is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \stringTyp }
     \quad (\stringT)
~ End InfRule

### Fixed-Width Signed Integer Types { #sec-signed-int-t }
Fixed-width singed integer types can have a literal integer as their width or an expression that will be evaluated to an integer at compile-time. Such intgeer must be more than one. 

$\intWidthTyp \exp$

- The expression representing the width must be a [well-formed integer][#sec-exp-type-checker].
- This expression must [evaluate to number at compile-time][#compileTimeEval], $\width$ denotes this number.
- $\width$ must be positive and more than one.

~ Begin InfRule
  \inferrule
     {\expCheck \exp \integerTyp   \\
     \compileTimeEval { \exp} = \width \\
     1 < \width} 
     { \typWellFormed {\intWidthTyp \exp} }
     \quad (\intWidthExpT)
~ End InfRule

### Fixed-Width Unsigned Integer Types { #sec-unsigned-int-t }
Fixed-width unsingned integer types are similar to singed integer types except that they require a non-negative width

$\bitWidthTyp \exp$

- The expression representing the width must be a [well-formed integer][#sec-exp-type-checker].
- This expression must [evaluate to a number at compile-time][#compileTimeEval], $\width$ denotes this number.
- $\width$ must be non-negative.

~ Begin InfRule
  \inferrule
     {\expCheck \exp \integerTyp  \\
     \compileTimeEval { \exp} = \width \\
     0 \leq \width} 
     { \typWellFormed {\bitWidthTyp \exp} }
     \quad (\bitWidthExpT)
~ End InfRule

### Variable-Width Integer Types { #sec-varbit-t }
Varbit types well-formedness is the same as fixed-width unsigned integer types.

$\varbitTyp \exp$

- The expression representing the width of the integer must be a [well-formed integer][#sec-exp-type-checker].
- This expression must [evaluate to a number at compile-time][#compileTimeEval], $\width$ denotes this number.
- $\width$ must be non-negative.


~ Begin InfRule
  \inferrule
     { \expCheck \exp \integerTyp  \\
     \compileTimeEval { \exp} = \width \\
     0 \leq \width}
     { \typWellFormed {\varbitTyp \exp} }
     \quad (\varbitExpT)

~ End InfRule

### Type Names { #sec-type-name-t }

### Specialized Types { #sec-specialized-t }

### Header Stack Types { #sec-stack-t }
Header stack (array) types are represented by a type and a size. Their type may be expressed either as a type name or a type specialization.


$\headerStackTyp \typName \exp$

- The name $\typName$ must be defined in the type environment $\typEnv$ and it is associated to the type $\typ$.
- The type $\typ$ must either be a [header or header union][#isHeaderOrUnion].
- The expression $\exp$ representing the size of the array must be a [well-formed integer][#sec-exp-type-checker].
- This expression must [evaluate to a number at compile-time][#compileTimeEval], denoted by $\int$.
- $\int$ must be positive.

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \lookupTypEnv \typName = \typ \\
       \isHeaderOrUnion {\typ} \\\\
       \expCheck \exp \integerTyp \\
       \compileTimeEval \exp = \size\\
       \size > 0
       % \isValidNestedTyp {\headerStackTyp {\surfaceTyp} \exp}
       }
     { \typWellFormed {\headerStackTyp {\typName} \exp} }}
     \quad (\arrayT)
~ End InfRule

$\headerStackTyp {\spcTyp \typName {\typArg}} \exp$

- The type specilization must be well-formed.
- The header stack type of the generic type without specialization must be well-formed. 


~ Begin InfRule
  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\spcTyp \typName {\typArg}}\\
       \typWellFormed {\headerStackTyp \typName \exp}
       }
     { \typWellFormed {\headerStackTyp {\spcTyp \typName {\typArg}} \exp} }}
     \quad (\arraySpecT)
~ End InfRule

### Tuple Types { #sec-tuple-t }

$\tupleTyps \typ$

- All the types inside a tuple type, i.e, $\typs$, must be well-formed.
- [Not every type can be wrapped inside a tuple type][#isValidNestedTyp]. Only the following types or a type name representing them can legally be wrapped inside a tuple type: ``what about types defined with typedef or type keywords? open issue on p4 spec``
   + $\bitWidthTyp \exp$
   + $\intWidthTyp \exp$
   + $\varbitTyp \exp$ 
   + $\errTyp$
   + $\boolTyp$
   + $\enumTypDef$ ``what about enums? since it doesn't have footnote i assumed it is allowed. open issue on p4 spec. same for struct.``
   + $\enumTypNoTypDef$
   + $\headerTyps \typParam \field \typ$
   + $\headerStackTyp \typName \exp$
   + $\headerUnionTyps \typParam \field \typ$
   + $\structTyps \typParam \field \typ$
   + $\tupleTyps \typ$
- A tuple type with no component, that is, $\tupleTyps {}$, is always well-type because it does not have any types that needs to satisfy the premises.

~ Begin InfRule
  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\typs} \\
        \isValidNestedTyp {\tupleTyps {\typ}}}
     { \typWellFormed {\tupleTyps {\typ}} }
     \quad (\tupleT)}
~ End InfRule

### Header Types { #sec-header-t }
Header types may be generic. This is expressed in two forms, however, there is no need to express this in two forms. We only do this to highlight that the generic one contains the non-generic one within it even though these two forms might seem differet. P4 has multiple generic types and we do not demonstrate this point for the rest of them although it still holds.

$\headerTyps { } \field \typ$

- The fields must be [distinct][#distinct].
- The types of the fields must be well-formed.
- [Not every type can be assigned to the fields][#isValidNestedTyp]. One of the folloing types or a type name representing them must be assigned to the fields:
   + $\bitWidthTyp \exp$ 
   + $\intWidthTyp \exp$ 
   + $\varbitTyp \exp$ 
   + $\boolTyp$
   + $\enumTypDef$
   + a struct or nested struct type that contains only the above types assigned to its fields ``why does it not allow varbit? open issue on p4 spec. also does the footnote 1 and 2 in the table of type nesting rules apply for all enums and sturcts or only when they're subtypes of headers?``

~ Begin InfRule

  \mprset {vskip = 0.7ex}
    {\inferrule
      {\distinct \fields \\
       \typWellFormed  {\typs} \\\\
       \isValidNestedTyp {\headerTyps { } \field {\typ}}}
      { \typWellFormed {\headerTyps { } \field {\typ}}}}
    \quad (\headerTypWellT)

~ End InfRule

$\headerTyps  \typParam \field \typ$

- The fields must be [distinct][#distinct].
- The types of the fields must be well-formed under the environment $\env$ that [its type parameter environment $\typParEnv$ has been extended with the type variables declared][#update-env-extension] for the header. Note that if the header is not generic the type parameter environment $\typParEnv$ will not be extended for checking if $\typs$ are well-formed.
- [Not every type can be assigned to the fields][#isValidNestedTyp]. Note that this is exactly the same for generic headers and non-generic headers. One of the following types or a type name representing them must be assigned to the fields:
   + $\bitWidthTyp \exp$ 
   + $\intWidthTyp \exp$ 
   + $\varbitTyp \exp$ 
   + $\boolTyp$
   + $\enumTypDef$
   + a struct or nested struct type that contains only the above types assigned to its fields
- Type variables must be [distinct][#distinct]. Note that if the header is not generic, that is, $\typParams = \emp$, the predicate $\distinct \typParams$ still holds.
- Type variables [must not be free][#noFreeTypVar], that is, every single type variable declared in the list $\typParams$ must be assigned to at least one of the header's fields. This is due to P4 not supporting phantom types. Similarly, if the header is not generic the predicate $\noFreeTypVar {\headerTyps { } \field {\typ}}$ still holds. ``are phantom types are useful in P4? i.e., do we want to allow free type variables in type decl? open issue on p4 spec. this goes for all generic type declarations such as struct.``

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {
       \distinct \fields \\
       \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\\\
       % \typWellFormedWithEnv \typEnv {\insertToTypParEnv \typParams} {\surfaceTyps} \\\\
       \isValidNestedTyp {\headerTyps  \typParam \field {\typ}}\\
       \distinct \typParams \\
       \noFreeTypVar {\headerTyps  \typParam \field {\typ}}
       }
      { \typWellFormed {\headerTyps  \typParam \field {\typ}}}}
    \quad (\headerGenericTypWellT)
~ End InfRule

As pointed out in the informal form, the $\headerGenericTypWellT$ rule contains the $\headerTypWellT$ rule within it since the premises that check a condition for type variables in a generic header still hold if the header is not generic. Thus, there is no need to have both rule, the $\headerGenericTypWellT$ rule suffices.

### Header Union Types { #sec-header-union-t }
Similar to headers, header unions may also be generic.

$\headerUnionTyps  \typParam \field {\typName}$

- The fields must be [distinct][#distinct].
- The type names assigned to the fields must [exist in the type environment][#lookup-env] $\typEnv$ and are corresponding to types $\typs$. Note that these header types are well-formed since they have already been stored in the enviornment.
- The types $\typs$ must be a [header type][#isHeader].
- The type parameters of the header union must be [distinct][#distinct].
- Type variables in the header union must [not be free][#noFreeTypVar].

~ Begin InfRule

  \mprset {vskip = 0.7ex}
    {\inferrule
      {
      \distinct \fields \\\\
       \lookupTypEnv \typNames = \typs \\
       % \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs \\
       \isHeader \typs\\\\
       \distinct \typParams\\
       \noFreeTypVar   {\headerUnionTyps  \typParam \field {\typName}}}
      { \typWellFormed {\headerUnionTyps  \typParam \field {\typName}}}}
    \quad (\headerUnionTypWellT)

~ End InfRule


### Struct Types { #sec-struct-t }

- The fields of the header must be [distinct][#distinct].
- The types of the fields must be well-formed under the environment $\env$ that [its type parameter evnironment $\typParEnv$ has been extended with the type variables declared][#update-env-extension] for the header.
- [Not every type can be assigned to the fields of a struct type][#isValidNestedTyp]. One of the following types or a type name representing them must be assigned to the fields:
   + $\bitWidthTyp \exp$
   + $\intWidthTyp \exp$
   + $\varbitTyp \exp$ 
   + $\errTyp$
   + $\boolTyp$
   + $\enumTypDef$
   + $\enumTypNoTypDef$
   + $\headerTyps \typParam \field \typ$
   + $\headerStackTyp \typName \exp$
   + $\headerUnionTyps \typParam \field \typ$
   + $\structTyps \typParam \field \typ$
   + $\tupleTyps \typ$
- Type variables must be [distinct][#distinct].
- Type variables must [not be free][#noFreeTypVar] in a struct type.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\distinct \fields \\
      \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\\\
       \isValidNestedTyp {\structTyps  \typParam \field {\typ}}\\
       \distinct \typParams\\
       \noFreeTypVar   {\headerUnionTyps  \typParam \field {\typName}}}
      {\typWellFormed {\structTyps  \typParam \field {\typ}}}
    }
    \quad (\structTypWellT)
~ End InfRule

### Enum Types { #sec-enum-t }

$\enumTypNoTypDef$

- An enum type is well-formed if its fields are [distinct][#distinct].

~ Begin InfRule
  % \mprset {vskip = 0.7ex}
    {\inferrule
      {\distinct \fields}
      {\typWellFormedNoEnv \enumTypNoTypDef}
    \quad (\enumWellT)}
~ End InfRule

### Serializable Enum Types { #sec-ser-enum-t }

Serializable enum types have an underlying type. This type may be expressed either as a type name that represents a type or a type. 

$\enumTyp {\VVal \typName} \typName \fields$

- The type name $\VVal \typName$ must [exist in the type synonym environment][#lookup-env] $\typSynEnv$ and is corresponding to the type $\typ$.
- The substituation of $\typ$ with $\typName$ as the underlying type of the enum must result in a well-formed enum.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\lookupTypSynEnv {\VVal \typName} = \typ \\
       \typWellFormed \enumTypDef
      }
      {\typWellFormed {\enumTyp {\VVal \typName} \typName \fields}}
    \quad (\serenumTypedefWellT)}
~ End InfRule

$\enumTypDef$

- The underlying type is [well-formed][#sec-type-type-checker].
- The underlying type is [either a fixed-width signed or unsigned integer][#isWidthInt].
- The fields are [distinct][#distinct]. 

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\typWellFormed \typ \\
       \isWidthInt {\typ} \\\\
       \distinct \fields}
      {\typWellFormed \enumTypDef}
    \quad (\serenumWellT)}
~ End InfRule

### Parser Types

### Control Types

### Package Types

### Function Types

### Set Types

### Extern Types

### Type Reference

### Action Types

### Constructor Types

### Table Types

### Void Type

### Don't Care Type

## Type Equality { #sec-type-eq-type-checker }

*todo: mention type equality is only done on well-formed types.*
*todo: explain sth like for type checking P4 programs we need to know if two type are equal or not. this judgment does it. for simplicity, and since after inference all type parameters have been substituted, there are no generic types in this section. a later section will introduce type eq for generic types.*

## Casting Types { #sec-casting-type-checker }

*todo: think/open issue on p4 spec: relationship between explicit and implicit cast. one subset of other or distinct or...?*

*todo: optimization opportunity: remove type well-formed check for implicit cast. on the other hand, having it double checks the work of type inference pass.*

*Casting $ {\bitWidthTyp 1}$ to $\boolTyp$*

- A bitstring type of width one can always be casted to $\boolTyp$ type.

~ Begin InfRuleHelper
  \inferrule
     { }
     { \allcastenv {\bitWidthTyp 1} \boolTyp }
     \quad (\rn{BitToBool}\rAE)
~ End InfRuleHelper

*Casting $\boolTyp$ to ${\bitWidthTyp 1}$*

- $\boolTyp$ type can always be casted to a bitstring type of width one.

~ Begin InfRuleHelper
  \inferrule
     { }
     { \allcastenv \boolTyp {\bitWidthTyp 1} }
     \quad (\rn{BoolToBit}\rAE)
~ End InfRuleHelper

*Casting $\integerTyp$ to $\boolTyp$*

- $\integerTyp$ type can always be casted to $\boolTyp$ type.

~ Begin InfRuleHelper
  \inferrule
     { }
     { \allcastenv {\integerTyp} \boolTyp }
     \quad (\rn{IntToBool}\rAE)
~ End InfRuleHelper

*Casting $\bitWidthTyp {\exp_1}$ to $\intWidthTyp {\exp_2}$* 

- The bitstring type $\bitWidthTyp {\exp_1}$ must be [well-formed][#sec-unsigned-int-t].
- The fixed-width signed integer type $\intWidthTyp {\exp_2}$ must be [well-formed][#sec-signed-int-t].
- Expressions $\exp_1$ and $\exp_2$ must be [evaluated at compile-time to integers][#compileTimeEval] $\width_1$ and $\width_2$, respectively.
- The integers $\width_1$ and $\width_2$ must be the same.
- Then, the bitstring type $\bitWidthTyp {\exp_1}$ can be casted to the fixed-width signed integer type $\intWidthTyp {\exp_2}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\bitWidthTyp {\exp_1}}\\
       \typWellFormed {\intWidthTyp {\exp_2}}\\\\
       \compileTimeEval {\exp_1} = \width_1 \\
       \compileTimeEval {\exp_2} = \width_2 \\\\
       \width_1 == \width_2 
       }
     { \allcastenv {\bitWidthTyp {\exp_1}} {\intWidthTyp {\exp_2}}}}
     \quad (\rn{UnsignedIntToSigned}\rAE)
~ End InfRuleHelper

*Casting $\intWidthTyp {\exp_1}$ to $\bitWidthTyp {\exp_2}$*

- The fixed-width signed integer type $\intWidthTyp {\exp_1}$ must be [well-formed][#sec-signed-int-t].
- The bitstring type $\bitWidthTyp {\exp_2}$ must be [well-formed][#sec-unsigned-int-t].
- Expressions $\exp_1$ and $\exp_2$ must be [evaluated at compile-time to integers][#compileTimeEval] $\width_1$ and $\width_2$, respectively.
- The integers $\width_1$ and $\width_2$ must be the same.
- Then, the fixed-width signed integer type $\intWidthTyp {\exp_1}$ can be casted to bitstring type $\bitWidthTyp {\exp_2}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\intWidthTyp {\exp_1}}\\
       \typWellFormed {\bitWidthTyp {\exp_2}}\\\\
       \compileTimeEval {\exp_1} = \width_1 \\
       \compileTimeEval {\exp_2} = \width_2 \\\\
       \width_1 == \width_2 
     }
     { \allcastenv {\intWidthTyp {\exp_1}} {\bitWidthTyp {\exp_2}}}}
     \quad (\rn{SignedIntToUnsigned}\rAE)
~ End InfRuleHelper

*Casting $\bitWidthTyp {\exp_1}$ to $\bitWidthTyp {\exp_2}$*

- A [well-formed bitstring type][#sec-unsigned-int-t] can always be casted to another well-formed bitstring type.

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\bitWidthTyp {\exp_1}}\\
       \typWellFormed {\bitWidthTyp {\exp_2}}}
     { \allcastenv {\bitWidthTyp {\exp_1}} {\bitWidthTyp {\exp_2}}}
     \quad (\rn{UnsignedIntToUnsignedInt}\rAE)
~ End InfRuleHelper

*Casting $\intWidthTyp {\exp_1}$ to $\intWidthTyp {\exp_2}$*

- A [well-formed fixed-width signed integer type][#sec-signed-int-t] can always be casted to another [well-formed fixed-width signed integer type][#sec-signed-int-t].

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\intWidthTyp {\exp_1}}\\
       \typWellFormed {\intWidthTyp {\exp_2}}}
     { \allcastenv {\intWidthTyp {\exp_1}} {\intWidthTyp {\exp_2}}}
     \quad (\rn{SignedIntToSignedInt}\rAE)
~ End InfRuleHelper

*Casting $\bitWidthTyp {\exp}$ to $\integerTyp$*

- A [well-formed bitstring type][#sec-unsigned-int-t] can always be casted to an integer type.

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\bitWidthTyp {\exp}}}
     { \allcastenv  {\bitWidthTyp \exp} \integerTyp}
     \quad (\rn{UnsignedIntToArbitraryPrecisionInt}\rAE)
~ End InfRuleHelper

*Casting $\intWidthTyp \exp$ to $\integerTyp$*

- A [well-formed fixed-width signed integer type][#sec-signed-int-t] can always be casted to an arbitrary-length integer type.

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\intWidthTyp {\exp}}}
     { \allcastenv   {\intWidthTyp \exp} \integerTyp}
     \quad (\rn{SignedIntToArbitraryPrecisionInt}\rAE)
~ End InfRuleHelper

*Casting $\integerTyp$ to $\bitWidthTyp \exp$*

- An arbitrary-length integer type can always be casted to a [well-formed bitstring type][#sec-unsigned-int-t].

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\bitWidthTyp {\exp}}}
     { \allcastenv \integerTyp {\bitWidthTyp \exp}}
     \quad (\rn{ArbitraryPrecisionIntToUnsignedInt}\rAE)
~ End InfRuleHelper

*Casting $\integerTyp$ to $\intWidthTyp \exp$*

- An arbitrary-length integer type can always be casted to a [well-formed fixed-width signed integer type][#sec-signed-int-t].

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\intWidthTyp {\exp}}}
     { \allcastenv  \integerTyp {\intWidthTyp \exp}}
     \quad (\rn{ArbitraryPrecisionIntToSignedInt}\rAE)
~ End InfRuleHelper

*Casting type synonym $\typName$ to type $\typ$*

- The type synonym $\typName$ must [exist in the type synonym environment][#lookup-env] $\typSynEnv$ and it corresponds to type $\typ$.
- Then, the type synonym $\typName$ can be casted to the type $\typ$.

~ Begin InfRuleHelper
  \inferrule
  { \lookupTypSynEnv \typName = \typ}
  { \allcastenv \typName \typ }
  \quad (\rn{TypedefToOriginal}\rAE)
~ End InfRuleHelper

*Casting type synonym $\typName_1$ to type synonym $\typName_2$*

- The type synonym $\typName_1$ must [exist in the type synonym environment][#lookup-env] $\typSynEnv$ and it corresponds to type $\typ_1$.
- The type synonym $\typName_2$ must [exist in the type synonym environment][#lookup-env] $\typSynEnv$ and it corresponds to type $\typ_2$.
- Type $\typ_1$ must be castable to type $\typ_2$.
- Then, type synony $\typName_1$ can be casted to type synonym $\typName_2$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
  { \lookupTypSynEnv {\typName_1} = \typ_1 \\
    \lookupTypSynEnv {\typName_2} = \typ_2 \\\\
    \allcastenv {\typ_1} {\typ_2}}
    % \typEqEnv \emp {\typ_1} {\typ_2} }
  { \allcastenv {\typName_1} {\typName_2} }}
  \quad (\rn{TypeSynonyms}\rAE)
~ End InfRuleHelper

*Casting type name $\typName$ to type $\typ$*

- The type name $\typName$ must [exist in the type environment][#lookup-env] $\typEnv$ and it corresponds to type $\typ$.
- Then, the type name $\typName$ can be casted to type $\typ$.


~ Begin InfRuleHelper
  \inferrule
  { \lookupTypEnv \typName = \typ}
  { \allcastenv \typName \typ }
  \quad (\rn{TypeToOriginal}\rAE)
~ End InfRuleHelper

*Casting $\enumTypDef$ to $\typ$*

- A [well-formed serializable enum type][#sec-ser-enum-t] can be casted to its underlying type. 

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed \enumTypDef}
     { \allcastenv {\enumTypDef} { {\typ}}}
     \quad (\rn{EnumToUnderlyingType}\rAE)
~ End InfRuleHelper

*Casting $\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}$ to $\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}$*

- Both serializable enum types $\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}$ and $\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}$ must be [well-formed][#sec-ser-enum-t].
- The underlying types of the serializable enum types, that is, $\typ_1$ and $\typ_2$, must be [the same][#sec-type-eq-type-checker].
- Then, the serializable enum type $\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}$ can be casted to the serializable enum type $\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}$.

~ Begin InfRuleHelper
  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}}\\
     \typWellFormed {\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}}\\\\
     \typEq {\typ_1} { {\typ_2}}}
     { \allcastenv {\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}} {\enumTyp { {\typ_2 }} { \typName_2} {\overline { \field_2}}}}}
     \quad (\rn{Enums}\rAE)
~ End InfRuleHelper

*Casting $\typ$ to $\enumTypDef$*

- The type $\typ$ can be casted to the [well-formed serializable enum type][#sec-ser-enum-t] $\enumTypDef$. Note that the well-formedness of the serializable enum type requires the underlying type $\typ$ to also be well-formed. Thus, we do not need to double-check that it is well-formed.

~ Begin InfRuleHelper
% expl
  \inferrule
     {\typWellFormed \enumTypDef}
     % \typEqEnv \emp {\surfaceTyp} {\VVal {\surfaceTyp}}}
     { \allcastenv {\typ} {\enumTypDef}}
     \quad (\rn{TypeToEnumWithUndrlyingType}\rAE)
~ End InfRuleHelper

*Casting $\tupleTyps \typ$ to $\headerTyps {} \field {\VVal \typ}$*

- The tuple type $\tupleTyps \typ$ must be [well-formed][#sec-tuple-t].
- The non-generic header type $\headerTyps {} \field {\VVal \typ}$ must be [well-formed][#sec-header-t].
- Either:
   + Types $\typs$ must be castable to types $\overline {\VVal \typ}$.
- Or:
   + The tuple types $\tupleTyps \typ$ and $\tupleTyps {\VVal \typ}$ must be [the same][#sec-type-eq-type-checker].
- Then, the tuple type $\tupleTyps \typ$ can be casted to the header type $\headerTyps {} \field {\VVal \typ}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\headerTyps {} \field {\VVal \typ}}\\\\
     \allcastenv {\typs} {\overline {\VVal \typ}} }
     {\allcastenv  {\tupleTyps {\typ}} {\headerTyps {} \field {\VVal \typ}}}}
     \quad (\rn{TupleToHeader}\rAE\rSep\rn{1})

\and

\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\headerTyps {} \field {\VVal \typ}}\\\\
      \typEq {\tupleTyps \typ} {\tupleTyps { {\VVal \typ}}}}
     {\allcastenv {\tupleTyps \typ} {\headerTyps {} \field {\VVal \typ}}}}
     \quad (\rn{TupleToHeader}\rAE\rSep\rn{2})
~ End InfRuleHelper

*Casting $\tupleTyps \typ$ to $\structTyps {} \field {\VVal \typ}$*

- The tuple type $\tupleTyps \typ$ must be [well-formed][#sec-tuple-t].
- The non-generic struct type $\structTyps {} \field {\VVal \typ}$ must be [well-formed][#sec-struct-t].
- Either:
   + Types $\typs$ must be castable to types $\overline {\VVal \typ}$.
- Or:
   + The tuple types $\tupleTyps \typ$ and $\tupleTyps {\VVal \typ}$ must be [the same][#sec-type-eq-type-checker].
- Then, the tuple type $\tupleTyps \typ$ can be casted to the struct type $\structTyps {} \field {\VVal \typ}$.


~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\structTyps {} \field {\VVal \typ}}\\\\
      \allcastenv {\typs} {\overline {\VVal \typ}}}
     {\allcastenv {\tupleTyps \typ} {\structTyps {} \field {\VVal \typ}}}}
     \quad (\rn{TupleToStruct}\rAE\rSep\rn{1})

\and

\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\structTyps {} \field {\VVal \typ}}\\\\
      \typEq {\tupleTyps \typ} {\tupleTyps { {\VVal \typ}}}}
     {\allcastenv {\listTyps \typ} {\structTyps \typParam \field {\VVal \typ}}}}
     \quad (\rn{TupleToStruct}\rAE\rSep\rn{2})
~ End InfRuleHelper

*Casting $\structTyps {} {\field_1} {\typ_1}$ to $\headerTyps {}  {\field_2} { \typ_2}$*

- The non-generic struct type $\structTyps {} {\field_1} {\typ_1}$ must be [well-formed][#sec-struct-t].
- The non-generic header type $\headerTyps {}  {\field_2} { \typ_2}$ must be [well-formed][#sec-header-t].
- Either:
   + Types $\overline {\typ_1}$ must be castable to types $\overline { \typ_2}$.
- Or:
   + The struct types $\structTyps {} {\field_1} {\typ_1}$ and $\structTyps {} {\field_2} {\typ_2}$ must be [the same][#sec-type-eq-type-checker].
- Then, the struct type $\structTyps {} {\field_1} {\typ_1}$ can be casted to the header type $\headerTyps {}  {\field_2} { \typ_2}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\structTyps {} {\field_1} {\typ_1}} \\
      \typWellFormed {\headerTyps {}  {\field_2} { \typ_2}}\\\\
      \allcastenv {\overline {\typ_1}} {\overline {\typ_2}}}
     {\allcastenv {\structTyps {} {\field_1} {\typ_1}} {\headerTyps {}  {\field_2} { \typ_2}}}}
     \quad (\rn{RecordToHeader}\rAE\rSep\rn{1})

\and 

\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\structTyps {} {\field_1} {\typ_1}} \\
      \typWellFormed {\headerTyps {}  {\field_2} { \typ_2}}\\\\
      \typEq {\structTyps {} {\field_1} {\typ_1}} {\structTyps {} {\field_2} { \typ_2}}}
     {\allcastenv {\structTyps {} {\field_1} {\typ_1}} {\headerTyps {} {\field_2} { \typ_2}}}}
     \quad (\rn{RecordToHeader}\rAE\rSep\rn{2})
~ End InfRuleHelper


## Expressions { #sec-exp-type-checker }
The type checker judgment for expressions has the form $\expCheck \exp \typ$ and it reads "the expression $\exp$ is well-formed with type $\typ$ under the enviornment $\env$". 


### Boolean Literals { #sec-bool-lit-type-checker }

$\bool$

- A boolean literal is well-formed.

~ Begin InfRule
  \inferrule
     { }
     {\expCheck  \bool \boolTyp}
     \quad (\boolE)
~ End InfRule

### String Literals { #sec-str-lit-type-checker }

$\str$

- A string literal is well-formed.

~ Begin InfRule
  \inferrule
     { }
     {\expCheck \str \stringTyp}
     \quad (\stringE)
~ End InfRule

### Integer Literfals { #sec-int-lit-type-checker }

$\int$

- An integer literal is well-formed.

~ Begin InfRule
  \inferrule
     { }
     {\expCheck \int  \integerTyp}
     \quad (\integerE)
~ End InfRule

### Fixed-Width Signed Integer Literals { #sec-int-width-lit-type-checker }

$\intWidth \int \width$

- A fixed-width signed integer literal is well-formed only if its width is positive.

~ Begin InfRule
  \inferrule
     { \width \geq 1}
     {\expCheck {\intWidth \int \width}  {\intWidthTyp \width}}
     \quad (\signedIntE)
~ End InfRule

### Fixed-Width Unsigned Integer Literals { #sec-bit-width-lit-type-checker }

$\bitWidth \int \width$

- A fixed-width unsigned integer literal is well-formed only if its width is non-negative.

~ Begin InfRule
  \inferrule
     { \width \geq 0}
     {\expCheck {\bitWidth \int \width} {\bitWidthTyp \width} }
     \quad (\bitStringE)
~ End InfRule

### Variables { #sec-var-type-checker }


### Array Access { #sec-array-access-type-checker }

Array access may take two forms, it can either access a header stack or a tuple. 

$\arrayAccess {\exp_1} {\exp_2}$ where $\exp_1 : \headerStackTyp \typ \size$

*todo: have to check this. the old note only mentioned that the tuple case is done.*

- The structure being accessed, that is, $\exp_1$, must be a well-formed header stack type, denoted by $\headerStackTyp \typ \size$.
- The access index must be a well-formed expression of a [numeric type][#isNumeric].
- Then, accessing the header stack $\exp_1$ at the index $\exp_2$ is well-formed with type $\typ$.


~ Begin InfRule
  \inferrule
     {\expCheck {\exp_1}  {\headerStackTyp \typ \size}  \\\\
      \expCheck {\exp_2} {\VVal \typ} \\\\
      % \isArray {\arrayTyp \typ \size} \\
      \isNumeric {\exp_2} {\VVal \typ}}
     {\expCheck {\arrayAccess {\exp_1} {\exp_2}} \typ }
     \quad (\arrayAccessE)
~ End InfRule

$\arrayAccess {\exp_1} {\exp_2}$ where $\exp_1 : \tupleTyp {\typ_1} {\typ_n}$

- The structure being accessed, that is, $\exp_1$, must be a well-formed tuple type with $n$ elements.
- The access index must be a well-formed integer type.
- The access index must [be evaluated to integer $\int$ at compile-time][#compileTimeEval].
- $\int$ must be between the bounds of the tuple type.
- Then, accessing the tuple $\exp_1$ at the index $\exp_2$ is well-formed with type $\typ_\int$.

~ Begin InfRule
  \inferrule
     {\expCheck {\exp_1}  {\tupleTyp {\typ_1} {\typ_n}} \\\\
      \expCheck {\exp_2}  {\integerTyp}  \\\\
      \compileTimeEval {\exp_2} = i\\
      1 \leq i \leq n}
     {\expCheck {\arrayAccess {\exp_1} {\exp_2}} {\typ_i} }
     \quad (\tupleAccessE)
~ End InfRule

### Bitstring Slicing { #sec-bitstring-slice-type-checker }

Bitstring slicing may occur over a fixed-width signed or unsigned integer. 

*todo: check why the context for exp 2 and 3 has to be constant. and when you encounter a new context explain it in notation section.*

$\bitStringAccess {\exp_1} {\exp_2} {\exp_3}$

- The bitstring slicing must be over a well-formed expression $\exp_1$. Either:
  + The type of $\exp_1$ must be a fixed-width unsigned integer $\bitWidthTyp \width$.
- Or:
  + The type of $\exp_1$ must be a fixed-width signed integer $\intWidthTyp \width$.
- Under a $\cte$ context, expressions representing the indices of slicing must be well-formed with one the following types, denoted by the [function *is\_num\_or\_enum*][#isNumOrEnum]:
   + $\integerTyp$
   + $\intWidthTyp \width$
   + $\bitWidthTyp \width$
   + $\enumTypDef$
- Expressions representing the lower and upper indices must [be evaluated to numbers $\int_1$ and $\int_2$, respectively, at compile-time][#compileTimeEval].
- The lower and upper indices of the slicing must be in bound of the width of the fixed-width integer and each other.
- Then, slicing a bitstring from index $\exp_2$ to $\exp_3$ is well-formed with type either:
   + $\bitWidthTyp {\int_2 - \int_1 + 1}$.
- Or:
   + $\intWidthTyp {\int_2 - \int_1 + 1}$.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule
     {\expCheck {\exp_1} {\bitWidthTyp \width} \\\\
      % \widthInt { {\typ_1}} = \width \\\\
      \expCheckEnv {\updateEnv {\ctxt = \cte}} {\exp_2} {\typ_2} \\\\ 
      \expCheckEnv {\updateEnv {\ctxt = \cte}} {\exp_3}  {\typ_3} \\\\ 
      \isNumOrEnum  {\typ_2} \\\\
      \isNumOrEnum  {\typ_3} \\\\
      \compileTimeEval { {\exp_2}} = \int_1 \\
      \compileTimeEval { {\exp_3}} = \int_2 \\\\
      0 \leq \int_1 < \width \\
      \int_1 \leq \int_2 < \width
      }
     {\expCheck {\bitStringAccess {\exp_1} {\exp_2} {\exp_3}} {\bitWidthTyp {\int_2 - \int_1 + 1}} }
     \quad (\bitSliceE)}

\and

\mprset {vskip=0.7ex}
  {\inferrule
     {\expCheck {\exp_1} {\intWidthTyp \width} \\\\
      % \widthInt { {\typ_1}} = \width \\\\
      \expCheckEnv {\updateEnv {\ctxt = \cte}} {\exp_2} {\typ_2}  \\\\
      \expCheckEnv {\updateEnv {\ctxt = \cte}} {\exp_3}  {\typ_3}  \\\\
      \isNumOrEnum  {\typ_2} \\\\
      \isNumOrEnum  {\typ_3} \\\\
      \compileTimeEval { {\exp_2}} = \int_1 \\
      \compileTimeEval { {\exp_3}} = \int_2 \\\\
      0 \leq \int_1 < \width \\
      \int_1 \leq \int_2 < \width
      }
     {\expCheck {\bitStringAccess {\exp_1} {\exp_2} {\exp_3}} {\intWidthTyp {\int_2 - \int_1 + 1}} }
     \quad (\intSliceE)}
~ End InfRule

### List Constructor { #sec-list-const-type-checker }

$\list \exps$

- Elements of the list must be well-formed with types $\typs$.
- Then, the list is well-formed with type $\listTyps \typ$.

~ Begin InfRule

  \inferrule
     {\expCheck {\exps} {\typs}}
     {\expCheck {\list \exps}{\listTyps \typ} }
     \quad (\listE)

~ End InfRule

### Record Constructor { #sec-record-const-type-checker }

$\records \exp$

- The fields are [distinct][#distinct].
- The expressions assigned to the fields are well-formed with types $\typs$.
- Then, the record is well-formed with type struct type $\structTyps { } \field \typ$.

~ Begin InfRule
  \inferrule
     {\distinct \fields \\
     \expCheck {\exps} {\typs}
      }
     {\expCheck {\records \exp}  {\structTyps { } \field \typ}  }
     \quad (\recordE)

~ End InfRule

### Unary Operations { #sec-unary-ops-type-checker }

P4 has three unary operations: logical negation, bitwise complement, and minus.

$\intoOp ! \exp$

- The expression $\exp$ must be well-formed with $\boolTyp$ type.
- Then, expression $\intoOp ! \exp$ is well-formed with $\boolTyp$ type.

~ Begin InfRule
  \inferrule
     { \expCheck \exp  \boolTyp }
     { \expCheck {\intoOp ! \exp}  \boolTyp }
     \quad (\logicalNegE)
~ End InfRule

$\intoOp \bitComplement \exp$

- The expression $\exp$ must be well-formed with a [fixed-width integer type][#isWidthInt] $\typ$.
- Then, the expression $\intoOp \bitComplement \exp$ is well-formed with type $\typ$.

~ Begin InfRule
  \inferrule
     { \expCheck \exp \typ \\
       \isWidthInt \typ }
     { \expCheck {\intoOp \bitComplement \exp} {\typ} }
     \quad (\bitwiseComplementE)
~ End InfRule

$\intoOp - \exp$

- The expression $\exp$ must be well-formed with a [numeric type][#isNumeric] $\typ$.
- Then, the expression $\intoOp - \exp$ is well-formed with type $\typ$.

~ Begin InfRule
  \inferrule
     { \expCheck \exp  \typ   \\
       \isNumeric \exp \typ}
     { \expCheck {\intoOp - \exp} {\typ} }
     \quad (\unaryMinusE)
~ End InfRule

### Binary Operations { #sec-bin-ops-type-checker }
P4 has around 15 binary operations. For each of them, some constraints must hold.

*todo: investigate the lack of in or less for directions.*

$\binOpExp {\&\&} {\exp_1} {\exp_2}$ or $\binOpExp \logor {\exp_1} {\exp_2}$

- Both operand expressions must be well-formed with $\boolTyp$ type.
- Then, the logical and/or expression is well-formed with $\boolTyp$ type. 

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{LogicalOps}\rAE(\ops=\intoOp {\&\&},\intoOp{\logor})]
     { \expCheck {\exp_1} {\boolTyp} \\
       \expCheck {\exp_2} {\boolTyp}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} \boolTyp }}
~ End InfRule


$\binOpExp {\intoOp +} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp -} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp *} {\exp_1} {\exp_2}$

- Both operand expressions must be well-formed with a [numeric type][#isNumeric].
- Operand expressions must have the [same type][#sec-type-eq-type-checker].
- Then, the addition/subtraction/multiplication expression is well-formed with a numeric type the same as its operands.

~ Begin InfRule
\mprset  {vskip=0.7ex}
  {\inferrule[\rn{NumericOps}\rE(\ops=\intoOp +, \intoOp -, \intoOp *)]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2}\\\\
       \isNumeric {\exp_1} {\typ_1}\\
       \isNumeric {\exp_2} {\typ_2}\\\\
       \typEq {\typ_1} {\typ_2}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} {\typ_1} }}
~ End InfRule

$\binOpExp {\intoOp {==}} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp {!=}} {\exp_1} {\exp_2}$

- Both operand expressions must be well-formed.
- The operand expressions must have the [same type][#sec-type-eq-type-checker].
- Their types must have defined [equality checking for expressions of this type][#typHasEq].
- The types of operand expression can be any type, however, [if they are $\integerTyp$ the expressions must be compile-time-known][#ifIntComp].
- Then, the equality/inequality expression is well-formed with $\boolTyp$ type. 

~ Begin InfRule
\mprset {vskip =0.7ex}
  {\inferrule[\rn{EqualityChecks}\rE(\ops=\ \intoOp{==}, \intoOp{!=})]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2}\\\\
       \typEq {\typ_1} {\typ_2} \\
       \typHasEq {\typ_1} \\\\
       \ifIntComp {\typ_1} {\exp_1} \\
       \ifIntComp {\typ_2} {\exp_2}
       }
     { \expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} \boolTyp  }}
~ End InfRule

$\binOpExp {\intoOp \plusSat} {\exp_1}  {\exp_2}$ or $\binOpExp {\intoOp \subSat} {\exp_1} {\exp_2}$

- Both operand expressions must be well-formed.
- The operand expressions must have the [same type][#sec-type-eq-type-checker].
- The operand expressions' types must be a [fixed-width integer type][#isWidthInt].
- Then, the saturating expression is well-formed with its operand's type.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{OpSat}\rE(\ops = \intoOp \plusSat,\intoOp \subSat)]
     { \expCheck {\exp_1}  {\typ_1} \\
       \expCheck {\exp_2}  {\typ_2} \\\\
       \typEq {\typ_1} {\typ_2}\\
       \isWidthInt {\typ_1} 
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} {\typ_1} }}
~ End InfRule

$\binOpExp {\intoOp \bitAnd} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp \bitOr} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp \bitXor} {\exp_1} {\exp_2}$

- Operand expressions must be well-formed. 
- The operand expression must have the [same type][#sec-type-eq-type-checker].
- The operand expressions' types must be a [fixed-width integer type][#isWidthInt].
- Then, the bitwise and/or/xor expression is well-formed with the same type as its operands.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{BitwiseOps}\rE(\ops=\intoOp \bitAnd, \intoOp \bitOr, \intoOp \bitXor)]
     { \expCheck {\exp_1}  {\typ_1} \\
       \expCheck {\exp_2} {\typ_2} \\\\
       \typEq {\typ_1} {\typ_2}\\
       \isWidthInt {\typ_1}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}}{\typ_1} }}
~ End InfRule

$\binOpExp {\intoOp \concat} {\exp_1}  {\exp_2}$

- The operand expressions must be well-formed.
- The operand expressions must have a fixed-width integer types $\typ_1$ and $\typ_2$.
- Then, the concatenation expression is well-formed with the [type $\concatCond {\typ_1} {\typ_2}$][#concatCond].

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{BitstringConcatenation}\rE]
     { \expCheck {\exp_1}  {\typ_1}\\
       \expCheck {\exp_2}  {\typ_2} \\\\
       \concatCond { {\typ_1}} { {\typ_2}} = \typ}
     {\expCheck {\binOpExp { \intoOp \concat} {\exp_1} {\exp_2}}  \typ }}
~ End InfRule

$\binOpExp { \intoOp <} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \leqOp} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp >} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \geqOp} {\exp_1} {\exp_2}$

- The operand expressions must be well-formed.
- The operand expression must have a [numeric type][#isNumeric].
- The operand expressions must have the [same type][#sec-type-eq-type-checker].
- Then, the comparison expression is well-formed with $\boolTyp$ type.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{ComparisonOps}\rE(\ops= \intoOp <, \intoOp \leqOp, \intoOp >, \intoOp \geqOp)]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2} \\\\
       \isNumeric {\exp_1} {\typ_1}\\
       \isNumeric {\exp_2} {\typ_2}\\\\
       \typEq{\typ_1} {\typ_2}
      }
    { \expCheck {\binOpExp \restOps {\exp_1} {\exp_2}}\boolTyp }}
~ End InfRule

$\binOpExp { \intoOp \div} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \mod} {\exp_1} {\exp_2}$

- The operand expressions must be well-formed with $\integerTyp$ type.
- Both operand expressions must be [evaluated to a non-negative number at compile-time][#nonNeg].
- Then, the division/modulo expression is well-formed with $\integerTyp$ type.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{DivOps}\rE(\ops=\intoOp\div, \intoOp\mod)]
     { \expCheck {\exp_1} {\integerTyp}  \\
       \expCheck {\exp_2} {\integerTyp} \\\\
       \nonNeg {\exp_1} \\
       \nonNeg {\exp_2}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} \integerTyp }}
~ End InfRule

$\binOpExp { \intoOp \shiftL} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \shiftR} {\exp_1} {\exp_2}$

- The operand expressions must be well-formed.
- The left-hand operand expression must have a [numeric type][#isNumeric], denoted by $\typ_1$.
- The right-hand expression $\exp_2$ must [satisfy one of the following][#shiftCond]:
   + its type is $\bitWidthTyp \width$
   + its type is $\integerTyp$ and $\nonNeg {\exp_2}$.
- Then, the shifting expression is well-formed with a type the same as its left-hand operand, that is, $\typ_1$.

~ Begin InfRule
  \inferrule[\rn{ShiftOps}\rE(\ops=\intoOp \shiftL, \intoOp \shiftR)]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2} \\\\
       \isNumeric {\exp_1} {\typ_1}\\
       \shiftCond {{\typ_2}} {\exp_2}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} { {\typ_1}} }
~ End InfRule


### Cast Operation { #sec-cast-type-checker }

Casting the type of an expression to another type may occur by representing the type by a name or directly referring to the type.

$\cast {\typName} \exp$

- The expression $\exp$ must be well-formed with type $\typ$.
- The type name $\typName$ must [exist in the type environment][#lookup-env] $\typEnv$ and it corresponds to the type $\VVal \typ$.
- The type $\typ$ must [be castable][#sec-casting-type-checker] to the type $\VVal \typ$.
- Then, the expression $\cast \typName \exp$ is well-formed.

~ Begin InfRule
\mprset {vskip = 0.7 ex}
  {\inferrule
     { \expCheck \exp {\typ}  \\
       \lookupTypEnv \typName = \VVal\typ\\\\
       \allcastenv {\typ} {\VVal \typ}}
       % \explicitCastOK {\typ_2} {\pprim \typ}}
     { \expCheck {\cast {\typName} \exp}  {\VVal \typ}  }}
     \quad (\castTypNameE)

~ End InfRule

$\cast {\typ} \exp$

- The expression $\exp$ must be well-formed with type $\VVal \typ$.
- The type $\VVal \typ$ must [be castable][#sec-casting-type-checker] to the type $ \typ$.
- Then, the expression $\cast \typ \exp$ is well-formed.

~ Begin InfRule
\mprset {vskip = 0.7 ex}
  {\inferrule
     { \expCheck \exp {\VVal \typ}  \\
       % \typ_2 = \sat {\typ_1} \\
       % \VVal \typ = \trans {\typ} {\emp} \\
       % \pprim \typ = \sat {\VVal \typ} \\
       % \typWellFormed {\VVal \typ} \\ %we don't even need to do this because the type has been generated.
       \allcastenv {\VVal \typ} {\typ}}
       % \explicitCastOK {\typ_2} {\pprim \typ}}
     { \expCheck {\cast {\typ} \exp} {\typ}  }}
     \quad (\castE)
~ End InfRule


### Type Member Operation { #sec-type-mem-type-checker }

### Error Member Operation { #sec-err-mem-type-checker }

### Expression Member Operation { #sec-exp-mem-type-checker }

### Conditional Operation { #sec-cond-type-checker }

$\ternary {\exp_1} {\exp_2} {\exp_3}$

- The condition expression $\exp_1$ must be well-formed with $\boolTyp$ type.
- The branch expressions $\exp_2$ and $\exp_3$ must be well-formed with types $\typ_1$ and $\typ_2$, respectively.
- The types of the branch expression, that is, $\typ_1$ and $\typ_2$, must be [the same][#sec-type-eq-type-checker].
- The types of the branch expression can be any type, however, [if they are $\integerTyp$ the condition expression must be compile-time-known][#ifIntComp].
- Then, the expression $\ternary {\exp_1} {\exp_2} {\exp_3}$ is well-formed with the same type as its branches, that is, $\typ_1$.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule
     {\expCheck {\exp_1} \boolTyp  \\\\
      \expCheck {\exp_2} {\typ_1} \\\\
      \expCheck {\exp_3} {\typ_2}\\\\
      \typEq {\typ_1} {\typ_2} \\
      \ifIntComp {\typ_1} {\exp_1}}
     {\expCheck {\ternary {\exp_1} {\exp_2} {\exp_3}} {\typ_1} }
     \quad (\ternaryE)}
~ End InfRule


### Function Call { #sec-func-call-type-checker }

### Anonymous Instantiation { #sec-ano-inst-type-checker }

### Bit Mask Operation { #sec-bit-mask-type-checker }

### Range Operation { #sec-range-type-checker }

$\range {\exp_1} {\exp_2}$

- The operand expressions both must be well-formed. 
- The types of the operand expressions must be [the same][#sec-type-eq-type-checker].
- The operand expressions' types $\typ_1$ and $\typ_2$ must be a [fixed-width integer types][#isWidthInt].
- Then, ranging from expression $\exp_1$ to $\exp_2$ is well-formed with the type $\setTyp {\typ_1}$.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule
     { \expCheck {\exp_1} {\typ_1} \\\\
       \expCheck {\exp_2} {\typ_2} \\\\
       \typEq {\typ_1} {\typ_2} \\
       \isWidthInt {\typ_1}}
       % \bothInt {\typ_1} {\typ_2}}
       % \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expCheck {\range {\exp_1} {\exp_2}} {\setTyp {\typ_1}}  }
     \quad (\rangeE)}
~ End InfRule


## Statements { #sec-stmt-type-checker }

## Declarations { #sec-dcl-type-checker }

The type checker judgment for declarations has the form $\dclCheck \dcl {\VVal \env}$ and it reads "under environment $\env$, the declaration $\dcl$ is well-formed and it updates the environment $\env$ to $\VVal \env$".

### Header Type Declaration { #sec-header-typ-decl-type-checker }

### Header Union Type Declaration { #sec-header-union-typ-decl-type-checker }

### Struct Type Declaration { #sec-struct-typ-decl-type-checker }

### Error Type Declaration { #sec-error-typ-decl-type-checker }

### Match Kind Type Declaration { #sec-matchkind-typ-decl-type-checker }

### Enum Type Declaration { #sec-enum-typ-decl-type-checker }

$\enumDcl \typName \field$

- The type of the declared enum type must be [well-formed][#sec-enum-t].
- Let $\VVal \env$ be the same environment as $\env$, but with
   + The type environment $ \typEnv$ extended with with the assignment of type $\enumTypNoTypDef$ to $\typName$.
   + The variable environment $ \varEnv$ extended with the assignments of the the enum type $\enumTypNoTypDef$ and $\less$ direction to enum field names prefixed with the enum name, that is, $\overline {\typMem \typName \field}$.
   + The constant environment $ \constEnv$ extended with the assignments of the enum field names prefixed with the enum type $\overline {\typMem \typName \field}$ to themselves, that is, $\overline {\typMem \typName \field}$.
- Then, the declared enum type is well-formed and it [updates the environment][#update-envs] to $\VVal \env$.

~ Begin InfRule
  \mprset{vskip=0.9ex}
  {\inferrule
     {\typWellFormed \enumTypNoTypDef\\\\
      \VVal \typEnv = \insertToTypEnv \typName {\enumTypNoTypDef}\\\\
       \VVal \varEnv = \insertsToVarEnv {\typMem \typName \field} \enumTypNoTypDef \less\\\\
       \VVal \constEnv = \insertsToConstEnv {\typMem \typName \field} {\enumVal \typName \field}}
     { \dclCheck {\enumDcl \typName \field} {\updateEnv {\VVal \varEnv, \VVal \constEnv, \VVal \typEnv}} }}
     \quad (\enumD)
~ End InfRule


### Serializable Enum Type Declaration { #sec-ser-enum-typ-decl-type-checker }

The underlying type of a serializable enum type may be a name that represents a type or the type itself. 

$\serEnumDcl {\VVal \typName} \typName \field \exp$

- The name $\VVal \typName$ representing the underlying type must [exist in the type synonym environment][#lookup-env] $\typSynEnv$.
- Let $\typ$ be the type corresponding to $\VVal \typName$ in the type synonym environment. 
- Substituting $\typ$ for $\typName$ in the serializable enum type declaration, that is, $\serEnumDcl {\typ} \typName \field \exp$, must be well-formed and it updates the environment to $\VVal \env$.
- Then, the serializable enum type declaration $\serEnumDcl {\VVal \typName} \typName \field \exp$ is well-formed and it updates the environment to $\VVal \env$.

~ Begin InfRule
  \mprset{vskip=0.7ex}
  {\inferrule
     { \lookupTypSynEnv {\VVal \typName} = \typ \\\\
       \dclCheck {\serEnumDcl {\typ} \typName \field \exp} {\VVal \env}
       }
     { \dclCheck {\serEnumDcl {\VVal \typName} \typName \field \exp} {\VVal \env}}}
     \quad (\serEnumTypdefD)
~ End InfRule

$\serEnumDcl {\typ} \typName \field \exp$

- The type of the declaration $\enumTypDef$ must be [well-formed][#sec-ser-enum-t].
- The expressions assigned to the enum fields must be [known at compile-time][#compTimeKnown].
- All the expressions assigned to the enum fields must be well-formed with type $\typ$. [refer to _[#valMatchTyp]_]
- Let $\VVal \env$ be the same environment as $\env$, but with
   + The type environment $\typEnv$ extended with the assignment of type $\enumTypDef$ to $\typName$.
   + The variable environment $\varEnv$ extended with the assignments of the the enum type $\enumTypDef$ and $\less$ direction to enum field names prefixed with the enum name, that is, $\overline {\typMem \typName \field}$.
   + The constant environment $ \constEnv$ extended with the assignments of the enum field names prefixed with the enum type $\overline {\typMem \typName \field}$ to themselves, that is, $\overline {\typMem \typName \field}$.
- Then, the declared enum type is well-formed and it [updates the environment][#update-envs] to $\VVal \env$.

~ Begin InfRule
  \mprset{vskip=0.9ex}
  {\inferrule
     { \typWellFormed \enumTypDef \\
       % \widthInt {\surfaceTyp} = \width \\
       % \isConstant \exp \\\\
       \compTimeKnown {\exps}\\\\
       \valMatchTyp \exp \typ\\\\
       \VVal \typEnv = \insertToTypEnv \typName {\enumTypDef}\\\\
       \VVal \varEnv = \insertsToVarEnv {\typMem \typName \field} \enumTypDef \less\\\\
       \VVal \constEnv = \insertsToConstEnv {\typMem \typName \field} {\enumVal \typName \field}
       }
     { \dclCheck {\serEnumDcl {\typ} \typName \field \exp} {\updateEnv {\VVal \varEnv, \VVal \constEnv, \VVal \typEnv}}}}
     \quad (\serEnumD)
~ End InfRule

### Type Definition { #sec-typdef-typ-decl-type-checker }

### Generative Type Definition { #sec-type-typ-decl-type-checker }

### Control Type Declaration { #sec-control-typ-decl-type-checker }

### Parser Type Declaration { #sec-parser-typ-decl-type-checker }

### Package Type Declaration { #sec-package-typ-decl-type-checker }


