# Notation { #sec-notation }

## Naming Convention
Each typing judgment may use auxiliary judgment and helper functions. The auxiliary
judgments are included in this document while the helper functions are just explained
in plain English.

Conventionally, in this document we accompany rule names with four possible suffixes:

- $\ruleNameT$ indicates that the rule is describing a rule for a type
- $\ruleNameE$ and $\ruleNameAE$ indicate that the rules are for an expression and an auxiliary judgment for an expression
- $\ruleNameS$ indicates that the rule is describing a rule for a statement
- $\ruleNameD$ indicates that the rule is describing a rule for a declaration

## rest

``TODO: add followings.``

- $\overline {\overline \anyTyp}$
- $\overline {X:\typ}$ zips $\overline X$ and $\typs$.
- $\concatList a b$

- The notation $\maybe \anyTyp$ denotes an optional type, that is, the type of $\anyTyp$ has been extended with bottom (maybe type in Haskell, or option type in OCaml). So if $\anyTyp$ denotes an integer, $\maybe \anyTyp$ could either be an integer number or bottom. 

The following describes the metavariables used in this document:

~ Center
| **metavariable**   |   **type represented** |
|:----------------:|:------------------|
| $\bool$ | booleans |
| $\str$ | strings |
| $\int$ | arbitrary length integer |
| $\width$ | width of a data structure |
| $\size$ | size of a data structure |
| $\bitWidth \bit \width$ | fixed length integer |
| $\intWidth \int \width$ | signed integer |
| $\name$ | strings representing any kinds of names |
| $\typ$ | types |
| $\dir$ | directions |
| $\typVar$ | type variables |
| $\wildcardParam$ | wild card type parameters |
| $\field$ | field names |
| $\env$ | environments |
| $\emp$ | empty list of elements |
| $\anyTyp$ | a value of any type |
| $\constraint$, $\optConstraint$, $\nonoptConstraint$ | constraints |
~


## Signatures { #sec-sig }

In this section, we provide the signatures used throughout this document including the judgment forms, environment signatures, and ``maybe function signatures``.

- Type well-formedness $\typWellFormed \typ$ ([rules][#sec-type-well-formed])
- Type equality $\typEqEnv {\overline {(\var, \prim \var)}} {\typ_1} {\typ_2}$ ([rules][#sec-type-eq])
- Expression typing $\expenv {\exp} {\prim \exp} \typ \dir $ ([rules][#sec-exp-typing])
- Statement typing $\stmtenv \stmt {\VVal \stmt} {\typ}$ ([rules][#sec-stmt-typing])
- Declaration typing $\dclenvvv \dcl {\VVal \dcl} {\VVal\env} {\VVal \typEnv}$ ([rules][#sec-decl-typing])


# Syntax { #sec-syntax }

In the following we present P4 syntax. Note that we omitted annotations and meta-information since they are not required for type checking. Some notes about the syntax follows:

- 
- Two types are provided. The first one is denoted by $\surfaceTyp \atyp$ which is the data types availabe in P4 language. The second one is denoted by $\typ$ and is the type generated by the type system which could be the result of a type declaration in a P4 program. 
- Parameters, denoted by $\prmDef \typKind$, are paremeterized by the type they have, that is, $\typKind$ represent a type where it can either be $\surfaceTyp \atyp$ or $\typ$. This is because they are used in different places and depending on where they are used they may have a different type. 
- For simplicity, we use the expanded format of parameter in most rules to have fine access to its direction and type. However, we often don't need its initializer so we omit that. Keep in mind that a parameter could or could not have an initializer.
- Direction is optional in parameter declaration. However, for simpilicity, we just use $\less$ to denote a missing direction. 

~ Begin P4Syntax
**Surface types:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\surfaceTyp \atyp $ | $::=$ | $\boolTyp$ | $\qquad \text{booleans}$ |
|   | $\vert$ | $\errTyp$ | $\qquad \text{errors}$ |
|   | $\vert$ | $\integerTyp$ | $\qquad \text{infinite-precision integers}$ |
|   | $\vert$ | $\intWidthTyp \atyp$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidthTyp \atyp$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\varBitTyp \atyp$ | $\qquad \text{variable-width integers with a maximum width}$ |
|   | $\vert$ | $\typName$ | $\qquad \text{type identifier}$ |
|   | $\vert$ | $\spcTyp {\surfaceTyp \atyp} {\surfaceTyp \atyp}$ | $\qquad \text{specialized type}$ |
|   | $\vert$ | $\stackTyp {\surfaceTyp \atyp} \atyp$ | $\qquad \text{stacks}$ |
|   | $\vert$ | $\tupleTyps {\surfaceTyp \atyp}$ | $\qquad \text{tuples}$ |
|   | $\vert$ | $\stringTyp$ | $\qquad \text{strings}$ |
{ .booktable }

**Argument types:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\argTyp$ | $::=$ | $\surfaceTyp \exp$ | $\qquad \text{surface types}$ |
|   | $\vert$ | $\voidTyp$ | $\qquad \text{void}$ |
|   | $\vert$ | $\dontcareTyp$ | $\qquad \text{don't care}$ |
|   | $\vert$ | $\identifierkw$ | $\qquad \text{identifier keyword}$ |
|   | $\vert$ | $\applykw$ | $\qquad \text{apply keyword}$ |
|   | $\vert$ | $\keykw$ | $\qquad \text{key keyword}$ |
|   | $\vert$ | $\actionskw$ | $\qquad \text{actions keyword}$ |
|   | $\vert$ | $\statekw$ | $\qquad \text{state keyword}$ |
|   | $\vert$ | $\entrieskw$ | $\qquad \text{entries keyword}$ |
|   | $\vert$ | $\typekw$ | $\qquad \text{type keyword}$ |
{ .booktable }

**Function prototype returned types:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\funcProTyp$ | $::=$ | $\surfaceTyp \exp$ | $\qquad \text{surface types}$ |
|   | $\vert$ | $\voidTyp$ | $\qquad \text{void}$ |
|   | $\vert$ | $\typVar$ | $\qquad \text{type variables}$ |
|   | $\vert$ | $\wildcard$ | $\qquad \text{wild cards}$ |
{ .booktable }


**Directions:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dir$ | $::=$ | $\inDir$ | $\qquad \text{copy-in}$ |
|   | $\vert$ | $\out$ | $\qquad \text{copy-out}$ |
|   | $\vert$ | $\inout$ | $\qquad \text{copy-in-out}$ |
|   | $\vert$ | $\less$ | $\qquad \text{direction-less}$ |
{ .booktable }

**Parameters:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\prmDef \typKind$ | $::=$ | $\dir \, \typKind \, \var$ | $\qquad \text{parameters}$ |
|   | $\vert$ | $\dir \, \typKind \, \var = \exp$ | $\qquad \text{parameters with value}$ |
{ .booktable }


**Unary operations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\unaryOp$ | $::=$ | $\intoOp !$ | $\qquad \text{logical negation}$ |
|   | $\vert$ | $\bitComplement$ | $\qquad \text{bitwise complement}$ |
|   | $\vert$ | $\intoOp -$ | $\qquad \text{unary minus}$ |
{ .booktable }

**Binary operations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\binOp$ | $::=$ | $\intoOp{\&\&}$ | $\qquad \text{logical and}$ |
|   | $\vert$ | $\intoOp \logor $ | $\qquad \text{logical or}$ |
|   | $\vert$ | $\intoOp +$ | $\qquad \text{numerical addition}$ |
|   | $\vert$ | $\intoOp -$ | $\qquad \text{numerical subtraction}$ |
|   | $\vert$ | $\intoOp *$ | $\qquad \text{numerical multiplication}$ |
|   | $\vert$ | $\intoOp \div$ | $\qquad \text{numerical division}$ |
|   | $\vert$ | $\intoOp \mod$ | $\qquad \text{numerical modulo}$ |
|   | $\vert$ | $\intoOp{==}$ | $\qquad \text{equality check}$ |
|   | $\vert$ | $\intoOp{!=}$ | $\qquad \text{inequality check}$ |
|   | $\vert$ | $\intoOp \plusSat$ | $\qquad \text{saturating addition}$ |
|   | $\vert$ | $\intoOp \subSat$ | $\qquad \text{saturation subtraction}$ |
|   | $\vert$ | $\intoOp \bitAnd$ | $\qquad \text{bitwise and}$ |
|   | $\vert$ | $\intoOp \bitOr$ | $\qquad \text{bitwise or}$ |
|   | $\vert$ | $\bitXor$ | $\qquad \text{bitwise xor}$ |
|   | $\vert$ | $\bitComplement$ | $\qquad \text{bitwise complement}$ |
|   | $\vert$ | $\intoOp \concat$ | $\qquad \text{bitwise concatenation}$ |
|   | $\vert$ | $\shiftL$ | $\qquad \text{shift left}$ |
|   | $\vert$ | $ \shiftR$ | $\qquad \text{shift right}$ |
|   | $\vert$ | $\intoOp <$ | $\qquad \text{less than}$ |
|   | $\vert$ | $ \leq$ | $\qquad \text{less than or equal}$ |
|   | $\vert$ | $\intoOp >$ | $\qquad \text{greater than}$ |
|   | $\vert$ | $ \geq$ | $\qquad \text{greater than or equal}$ |
{ .booktable }

**Arguments:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\arg$ | $::=$ | $\argexp$ | $\qquad \text{expression}$ |
|   | $\vert$ | $\argkv$ | $\qquad \text{key value}$ |
|   | $\vert$ | $\missingarg$ | $\qquad \text{missing}$ |
{ .booktable }

**Expressions:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\exp$ | $::=$ | $\bool$ | $\qquad \text{booleans}$ |
|   | $\vert$ | $\str$ | $\qquad \text{strings}$ |
|   | $\vert$ | $\int$ | $\qquad \text{integers}$ |
|   | $\vert$ | $\intWidth \int \width$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidth \bit \width$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\name$ | $\qquad \text{names (variables)}$ |
|   | $\vert$ | $\arrayAccess {\exp_1} {\exp_2}$ | $\qquad \text{array accesses}$ |
|   | $\vert$ | $\bitStringAccess {\exp_1} {\exp_2} {\exp_3}$ | $\qquad \text{bitstring slices}$ |
|   | $\vert$ | $\list \exps$ | $\qquad \text{lists}$ |
|   | $\vert$ | $\records \exp$ | $\qquad \text{records}$ |
|   | $\vert$ | $\unaryOp \exp$ | $\qquad \text{unary operations}$ |
|   | $\vert$ | $\exp_1 \binOp \exp_2$ | $\qquad \text{binary operations}$ |
|   | $\vert$ | $\cast {\surfaceTyp \exp} \exp$ | $\qquad \text{casts}$ |
|   | $\vert$ | $\typMem \typVar \field$ | $\qquad \text{type members}$ |
|   | $\vert$ | $\errMem \field$ | $\qquad \text{error members}$ |
|   | $\vert$ | $\expMem \exp \field$ | $\qquad \text{expression members}$ |
|   | $\vert$ | $\ternary {\exp_1} {\exp_2} {\exp_3}$ | $\qquad \text{conditionals}$ |
|   | $\vert$ | $\funcCall \exp {\surfaceTyps \exp} \args$ | $\qquad \text{function calls}$ |
|   | $\vert$ | $\instantiation {\surfaceTyp \exp} {\args}$ | $\qquad \text{anonymous instantiation}$ |
|   | $\vert$ | $\mask {\exp_1} {\exp_2}$ | $\qquad \text{bit masks}$ |
|   | $\vert$ | $\range {\exp_1} {\exp_2}$ | $\qquad \text{ranges}$ |
{ .booktable }

**Labels:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\lbl$ | $::=$ | $\defLbl$ | $\qquad \text{default}$ |
|   | $\vert$ | $\str$ | $\qquad \text{string labels}$ |
{ .booktable }

**Switchs:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\switchCase$ | $::=$ | $\actionCase \stmts$ | $\qquad \text{labeled block}$ |
|   | $\vert$ | $\lbl$ | $\qquad \text{fall through with label}$ |
{ .booktable }

**Statements:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\stmt$ | $::=$ | $\methodCall \exp {\surfaceTyps \exp} \args$ | $\qquad \text{method call}$ |
|   | $\vert$ | $\assign {\exp_1} {\exp_2}$ | $\qquad \text{assignment}$ |
|   | $\vert$ | $\dirApp {\surfaceTyp \exp}\args$ | $\qquad \text{direct application}$ |
|   | $\vert$ | $\ifthen \exp \stmt$ | $\qquad \text{if then}$ |
|   | $\vert$ | $\ifthenelse \exp {\stmt_1} {\stmt_2}$ | $\qquad \text{if then else}$ |
|   | $\vert$ | $\block \stmts$ | $\qquad \text{sequencing}$ |
|   | $\vert$ | $\exit$ | $\qquad \text{exit}$ |
|   | $\vert$ | $\noop$ | $\qquad \text{noop}$ |
|   | $\vert$ | $\return \exp$ | $\qquad \text{return}$ |
|   | $\vert$ | $\retNothing$ | $\qquad \text{return nothing}$ |
|   | $\vert$ | $\switch \exp \switchCases$ | $\qquad \text{switch}$ |
|   | $\vert$ | $\dcl$ | $\qquad \text{declaration}$ |
{ .booktable }

**Parser states:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\nxt$ | $::=$ | $\str$ | $\qquad \text{next state}$ |
|   | $\vert$ | $\accept$ | $\qquad \text{accept state}$|
|   | $\vert$ | $\reject$ | $\qquad \text{reject state}$|
| $\pmatch$ | $::=$ | $\defMatch$ | $\qquad \text{default match}$ |
|   | $\vert$ | $\dontcareMatch$ | $\qquad \text{don't care match}$ |
|   | $\vert$ | $\exp$ | $\qquad \text{expression match}$ |
| $\case$ | $::=$ | $\expandCase \pmatches \nxt$ | $\qquad \text{match cases for the next state}$ |
| $\parserTran$ | $::=$ | $\nxt$ | $\qquad \text{next state transition}$ |
|   | $\vert$ | $\slctTran \exp \pcases$ | $\qquad \text{select next state transition}$ |
| $\state$ | $::=$ | $\stateDef \var \stmts \parserTran$ | $\qquad \text{states}$ |
{ .booktable }

**Table properties:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\action$ | $::=$ | $\actionDef \var \arg$ | $\qquad \text{actions}$ |
| $\prop$ | $::=$ | $\key \exp \var$ | $\qquad \text{keys}$ |
|   | $\vert$ | $\action$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\entry \pmatch \action$ | $\qquad \text{entries}$ |
|   | $\vert$ | $\custom \bool \var \exp$ | $\qquad \text{custom property}$ |
{ .booktable }

**Methods:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\extMethod$ | $::=$ | $\constructor \var {\prmDef {\surfaceTyp \exp}}$ | $\qquad \text{constructors}$ |
|   | $\vert$ | $\abstractMethod {\surfaceTyp \exp}\var \typVar {\prmDef {\surfaceTyp \exp}}$ | $\qquad \text{abstract methods}$ |
|   | $\vert$ | $\methodDef {\surfaceTyp \exp}\var \typVar {\prmDef {\surfaceTyp \exp}}$ | $\qquad \text{methods}$ |
{ .booktable }

**Declarations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\constDcl {\surfaceTyp \exp}\var \exp$ | $\qquad \text{constants}$ |
|   | $\vert$ | $\inst {\surfaceTyp \exp}\args \var \stmts$ | $\qquad \text{instantiations (initialized)}$ |
|   | $\vert$ | $\instNoBlock {\surfaceTyp \exp}\args \var$ | $\qquad \text{instantiations (uninitialized)}$ |
|   | $\vert$ | $\parserDcl \var \typVars {\overline { {\prmDef {\surfaceTyp \exp}}}} {\overline {\VVal {\prmDef {\surfaceTyp \exp}}}} \dcls \states$ | $\qquad \text{parsers}$ |
|   | $\vert$ | $\controlDcl \var \typVars {\overline { {\prmDef {\surfaceTyp\exp}}}} {\overline {\VVal {\prmDef {\surfaceTyp \exp}}}} \dcls \stmts$ | $\qquad \text{controls}$ |
|   | $\vert$ | $\funcDcl {\surfaceTyp \exp}\var \typVars {\prmDefs {\surfaceTyp \exp}} \stmts$ | $\qquad \text{functions}$ |
|   | $\vert$ | $\externFuncDcl {\surfaceTyp \exp}\var \typVars {\prmDefs {\surfaceTyp \exp}}$ | $\qquad \text{extern functions}$ |
|   | $\vert$ | $\varDclInit {\surfaceTyp \exp}\var \exp$ | $\qquad \text{local variables (initialized)}$ |
|   | $\vert$ | $\varDcl {\surfaceTyp \exp}\var$ | $\qquad \text{local variables (uninitialized)}$ |
|   | $\vert$ | $\valSetDcl {\surfaceTyp \exp}\exp \var$ | $\qquad \text{parser value sets}$ |
|   | $\vert$ | $\actionDcl \var {\prmDefs {\surfaceTyp \exp}} \stmts$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\tableDcl \var \props$ | $\qquad \text{tables}$ |
|   | $\vert$ | $\headerDcl \typVar \fieldTyps$ | $\qquad \text{header types}$ |
|   | $\vert$ | $\headerUnionDcl \typVar \fieldTyps$ | $\qquad \text{header union types}$ |
|   | $\vert$ | $\structDcl \typVar \fieldTyps$ | $\qquad \text{struct types}$ |
|   | $\vert$ | $\errDcl \fields$ | $\qquad \text{error types}$ |
|   | $\vert$ | $\matchkindDcl \fields$ | $\qquad \text{match kind types}$ |
|   | $\vert$ | $\enumDcl \typVar \fields$ | $\qquad \text{enumerated types}$ |
|   | $\vert$ | $\serEnumDcl {\surfaceTyp \exp}\typVar \field \exp$ | $\qquad \text{serializable enumerated types}$ |
|   | $\vert$ | $\externObjDcl \var \typVars \extMethods$ | $\qquad \text{extern objects}$ |
|   | $\vert$ | $\typdefDcl \typVar {\surfaceTyp \exp}$ | $\qquad \text{type definitions}$ |
|   | $\vert$ | $\typdefDcl \typVar \dcl$ | $\qquad \text{type definitions (declarations)}$ |
|   | $\vert$ | $\newtypeDcl  {\surfaceTyp \exp}\typVar$ | $\qquad \text{generative type definitions}$ |
|   | $\vert$ | $\newtypeDcl  \dcl \typVar$ | $\qquad \text{generative type definitions (declarations)}$ |
|   | $\vert$ | $\controlTypDcl \typVar \typVars {\prmDefs {\surfaceTyp \exp}}$ | $\qquad \text{control types}$ |
|   | $\vert$ | $\parserTypDcl \typVar \typVars {\prmDefs {\surfaceTyp \exp}}$ | $\qquad \text{parser types}$ |
|   | $\vert$ | $\packageTypDcl \typVar \typVars {\prmDefs {\surfaceTyp \exp}}$ | $\qquad \text{package types}$ |
{ .booktable }

**Programs:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\prog$ | $::=$ | $\dcls$ | $\qquad \text{programs}$ |
{ .booktable }

~ End P4Syntax


# Type Related Judgments { #sec-types-typing }

Three judgments are provided for types of P4 expressions:

[alpha-equiv-wiki]: https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence

- [type well-formedness][#sec-type-well-formed]: ensures the lack of specific errors in types, that is, types are well-formed.
- [type equality][#sec-type-eq]: checks the [alpha equalency][alpha-equiv-wiki] of two types.
- [type unification][#sec-type-unify]: tries to unify two types by providing constraints of assignment of types to type variables. 


~ Begin P4Syntax
**Declared types:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\declaredTyp$ | $::=$ | $blah$ | $\qquad \text{blah}$ |
|   | $\vert$ | $\headerTyps \field \typ$ | $\qquad \text{headers}$ |
|   | $\vert$ | $\headerUnionTyps \field \typ$ | $\qquad \text{header unions}$ |
|   | $\vert$ | $\structTyps \field \typ$ | $\qquad \text{structs}$ |
|   | $\vert$ | $\enumTypDef$ | $\qquad \text{serializable enums}$ |
|   | $\vert$ | $\enumTypNoTypDef$ | $\qquad \text{enums}$ |
|   | $\vert$ | $\parserTyp \typParams {\prmDefs \typ}$ | $\qquad \text{parsers}$ |
|   | $\vert$ | $\controlTyp \typParams {\prmDefs \typ}$ | $\qquad \text{controls}$ |
|   | $\vert$ | $\packageTyp \typParams {\prmDefs \typ}$ | $\qquad \text{packages}$ |
|   | $\vert$ | $\recordTyps \field \typ$ | $\qquad \text{records}$ |
|   | $\vert$ | $\matchKindTyp$ | $\qquad \text{match kinds}$ |
|   | $\vert$ | $\newTypeTyp \typVar \typ$ | $\qquad \text{reference}$ |
|   | $\vert$ | $\actionTyp {\overline { {\prmDef \typ}}} {\overline {\VVal {\prmDef \typ}}}$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\constructorTyp \typParams {\prmDefs \typ} \typ$ | $\qquad \text{constructors}$ |
|   | $\vert$ | $\tableTyp \name$ | $\qquad \text{tables}$ |
{ .booktable }

**Synthesized types:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\synTyp$ | $::=$ | blah | $\qquad \text{blah}$ |
|   | $\vert$ | $\funcType \kind \typParams {\prmDefs \typ} \typ$ | $\qquad \text{functions}$ |
|   | $\vert$ | $\setTyp \typ$ | $\qquad \text{sets}$ |
|   | $\vert$ | $\externTyp \name$ | $\qquad \text{externs}$ |
{ .booktable }

**Types produced by the type system:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\surfaceTyp \width $ | $\qquad \text{surface types} |
|   | $\vert$ | $\synTyp$ | $\qquad \text{synthesized types} |
|   | $\vert$ | $\declaredTyp$ | $\qquad \text{declared types} |
|   | $\vert$ | $\intWidthTyp \width$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidthTyp \width$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\varBitTyp \width$ | $\qquad \text{variable-width integers}$ |
|   | $\vert$ | $\typVar$ | $\qquad \text{type variables}$ |
|   | $\vert$ | $\arrayTyp \typ \width$ | $\qquad \text{arrays}$ |
|   | $\vert$ | $\voidTyp$ | $\qquad \text{void}$ |
{ .booktable }


~ End P4Syntax

## Type Well-Formed Judgment { #sec-type-well-formed }

``todo: this must be defined on surface types.``

This judgment checks if a type is well-formed. Note that this judgment is defined over the expression types and not P4's data types.
It has the form $\typWellFormed \typ$ which states that the type $\typ$
is well-formed under the type environment $\typEnv$ and extern environment $\externEnv$, that is, the type is syntactically correct. 

All typing rules first saturate all types,
that is, it eliminates all type references in type
$\typ$ and replaces them with the type they refer to. Thus, the result of saturation
contains no type synonym (_TypeName_ in Petr4) constructors that are used to give a name to a new type. Then it checks the well-formedness of the saturated type.
For brevity, we don't include the saturation in rules.

### Base Types { #sec-base-t }

The following base types are well-formed unconditionally since there is not any room for an error while constructing a value of these types. For example, the $\boolTyp$ only has two constructors $\mathit{true}$ and $\mathit{false}$ which do not take any argument so there is no room to construct a value incorrectly.

~ Begin InfRule

  \inferrule
     { }
     { \typWellFormed \boolTyp }
     \quad (\boolT)

\and

  \inferrule
     { }
     { \typWellFormed \stringTyp }
     \quad (\stringT)

\and

  \inferrule
     { }
     { \typWellFormed \integerTyp }
     \quad (\intT)

\and

  \inferrule
     { }
     { \typWellFormed {\varBitTyp \width} }
     \quad (\varbitT)

\and

  \inferrule
     { }
     { \typWellFormed \errTyp}
     \quad (\errT)

\and

  \inferrule
     { }
     { \typWellFormed \voidTyp}
     \quad (\voidT)

\and

  \inferrule
     { }
     { \typWellFormed \matchKindTyp}
     \quad (\matchKindT)

\and

  \inferrule
     { 1 < \width} % p4 spec has this
     %% { }
     { \typWellFormed {\intWidthTyp \width} }
     \quad (\intWidthT)

\and

  \inferrule
     { 0 \leq \width} % p4 spec has this
     %% { }
     { \typWellFormed {\bitWidthTyp \width} }
     \quad (\bitWidthT)

~ End InfRule

### Array Type { #sec-array-t }

An array type has a specific type and size.
The rule $\arrayT$ states that under environment $\env$, an array is well-formed if its
type is well-formed and it follows the nesting rules of P4.

- $\isValidNestedTyp \typ$ checks whether the nested type $\typ$ is valid, that is,
it checks if all the subtypes in the type $\typ$ can actually be inner types of $\typ$ based on [P4's description of type nesting rules][sec7-2-7].

[sec7-2-7]: https://p4.org/p4-spec/docs/P4-16-v1.2.0.html#sec-type-nesting 

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ \\
       \isValidNestedTyp {\arrayTyp \typ \size}}
     { \typWellFormed {\arrayTyp \typ \size} }
     \quad (\arrayT)

~ End InfRule

### Tuple/List Type { #sec-tuple-t }

Each element of a tuple/list can have a distinct type so a tuple type is simply a list of types. Note that lists also have a tuple type. The rule $\tupleT$ states that under
environment $\env$, a tuple type is well-formed if all its types are well-formed and it
follows the nesting typing rules of P4. 

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed \typs \\
        \isValidNestedTyp {\tupleTyps \typs}}
     { \typWellFormed {\tupleTyps \typs} }
     \quad (\tupleT)}

  % \inferrule[List]
  %    { 1 \leq i \leq n. \typWellFormed {\typ_i} \\
  %      1 \leq i \leq n.  \isValidNestedTyp {\listTyp {\typ_1} {\typ_n}} {\typ_i}}
  %    { \typWellFormed {\listTyp {\typ_1} {\typ_n}} }

~ End InfRule

### Set Type { #sec-set-t }

In P4, unlike tuples, elements of a set must all have the same type and the set type is well-formed if the type of its elements is well-formed, which is stated by the $\setT$ rule.

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ }
     { \typWellFormed {\setTyp \typ} }
     \quad (\setT)

~ End InfRule

### Enumeration Type { #sec-enum-t }

An enumeration type contains a number of constants of string type and its declaration introduces a new identifier in the current naming scope. It could also have an underlying representation which states what is the type of its constants.
The rules below state that an enum type is well-formed if the underlying representation is well-formed, if it has one. 


~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { }
     { \typWellFormed \enumTypNoTypDef }
     \quad (\enumOneT)}

\and

  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed \typ }
     { \typWellFormed \enumTypDef }
     \quad (\enumTwoT)}

~ End InfRule

### Record Type { #sec-record-t }

A record has zero or more fields, which each field has a name and a type.
The rule $\recordT$ states that a record type is well-formed if all its fields have well-formed types, all fields have types that can be nested in a record, and fields have distinct names. 

Note that headers, header unions, and struct also have the same type and their well-formedness is defined the same.

- $\noDup \names$ checks that there is no duplicate name in $\names$. Remember that fields are just names (strings).

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed \typs \\
       \isValidNestedTyp {\recordTyps \field \typ} \\
       \noDup \fields}
     { \typWellFormed {\recordTyps \field \typ} }
     \quad (\recordT)}

\and

  \mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed \typs \\
       \isValidNestedTyp {\headerUnionTyps \field \typ} \\\\
       \noDup \fields}
     { \typWellFormed {\headerUnionTyps \field \typ} }
     \quad (\headerUnionT)}

\and

  \mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed \typs \\
       \isValidNestedTyp {\structTyps \field \typ} \\
       \noDup \fields}
     { \typWellFormed {\structTyps \field \typ} }
     \quad (\structT)}

\and

  \mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed \typs \\
       \isValidNestedTyp {\headerTyps \field \typ} \\
       \noDup \fields}
     { \typWellFormed {\headerTyps \field \typ} }
     \quad (\headerT)}

~ End InfRule

### New Type Type { #sec-newtype-t }

New type assigns a name to a type. So the $\newTypeT$ checks if the assignee type $\typ$ is well-formed.

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ }
     { \typWellFormed {\newTypeTyp \typVar \typ} }
     \quad (\newTypeT)

~ End InfRule

### Specialized Type { #sec-specialized-t }

An specialized type specifies the types of parameters in a generic type, the underlying generic type in an specialized type is called the base type. An specialized type is necessary when the compiler cannot infer type arguments.

The rule $\specializedExternT$ states that the specialization of an extern type is well-formed if the extern $\name$ exists in the environment $\env$ and the specialization specifies the type of all its type parameters. Similarly, the rule $\specializedRestT$ states that the specialization of a package/control/parser/function is well-formed if it specifies the type of all its type parameters.

- $\lookupExternEnv \name$ looks up a variable $\name$ in extern environment $\externEnv$ and it returns the type parameters and methods of the extern. Since the rule $\specializedExternT$ only cares about the parameters we do not care about the methods, thus, we don't assign a variable name to it and use an underscore instead of it. 
- $\getTypeParams \typ$ returns the type parameters from types that have type parameters including package, control, parser, and function.

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \lookupExternEnv \name = ([\params], \_ ) \\
        % 1 \leq i \leq n. \typWellFormed {\typ_i} \\
        \typWellFormed \typs\\
        |\typs| = |\params|}
     { \typWellFormed {\spcTyp {\externTyp \name} \typs} }
     \quad (\specializedExternT)}

\and

  \mprset {vskip=0.7ex}
  {\inferrule
     { \getTypeParams \typ = \{\params\}\\
        \typWellFormed {\typs} \\
        |\params| = |\typs|}
     { \typWellFormed {\spcTyp \typ {\typs}} }
     \quad (\specializedRestT)}

~ End InfRule

### Package Type { #sec-package-t }

A package type describes the signature of a package and it defines the type parameters and parameters of a package. It may also have wildcard parameters. 
The rule $\packageT$ states that a package type is well-formed under the environment $\typEnv$ extended with the package's type parameters if all its parameters are direction-less and their types are well-formed. 

- $\extendTypEnv \typVar$ extends the type environment $\typEnv$ with type variable $\typParam$. Note that the type inserted in the environment for a type variable is a type name.
- $\isDirectionless \dir$ checks that the direction of parameter $\dir$ is $\less$ or not.

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { \isDirectionless {\dir} \\
         \typWellFormedWithEnv {\extendTypsEnv \typVar} \typs }
       { \typWellFormed {\packageTyp {\typParams} {\prms} } }
     \quad (\packageT)}

~ End InfRule

### Control and Parser Type { #sec-control-t }

A control type is similar to a type signature of a function in that it defines the type parameters used in the control and its parameters, however, it does not have a return type. The rule $\controlT$ states that the control type is well-formed under the environment $\typEnv$ extended with type variables $\typParams$ if all the types of its parameters are well-formed.


~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormedWithEnv {\extendTypsEnv \typParam} {\typs}}
       { \typWellFormed {\controlTyp {\typParams} {\prms} } }
       \quad (\controlT)}

\and

  \mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormedWithEnv {\extendTypsEnv \typParam} {\typs}}
       { \typWellFormed {\parserTyp {\typParams} {\prms} } }
       \quad (\parserT)}

~ End InfRule

### Extern Type { #sec-extern-t }

The rule $\externT$ states that an extern type is well-formed if it has no type parameter in the environment. 
$\lookupExternEnv \name$ where $\name$ is an extern returns an externMethods type which includes a list of strings as
type parameters which must be empty for it to be well-typed and a function type which doesn't care for function type.


~ Begin InfRule

  \inferrule
     { \lookupExternEnv \name = (\emp, \_ )}
     { \typWellFormed {\externTyp \name} }
     \quad (\externT)

~ End InfRule

### Function Type { #sec-func-t }

A function type describes the return type of the function, its type parameters, and its parameters. The rule $\functionT$ states that the function type is well-formed if its return type is well-formed and the types of its parameters are well-formed under environment $\typEnv$, extended with function's type parameters. 

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed \typ \\
       \typWellFormedWithEnv {\extendTypsEnv \typVar} \typs}
       % 1 \leq i \leq n. \typWellFormedWithEnv {\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}} {\typ_i} }
     % <return type> <function name>(x1,...,xn) {...}
     { \typWellFormed {\funcType \kind {\typParams} {\prms} \typ} }
     \quad (\functionT)}

~ End InfRule

### Action Type { #sec-action-t }

An action type defines data and control parameters and it is well-formed if the types of all parameters are well-formed and the control parameters are direction-less.

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     {  \typWellFormed {\typs} \\
        \typWellFormed {\overline {\prim \typ}} \\
       \isDirectionless \dirs \\
       \isDirectionless {\overline {\prim \dir}}}
     { \typWellFormed {\actionTyp {\prms} {\prmss}} }
     \quad (\actionT)}

~ End InfRule

### Constructor Type { #sec-constructor-t }

The rule $\constructorT$ states that a constructor type is well-formed if its return type $\typ$ is well formed and the types of its parameters are well-formed under the environment $\typEnv$ extended with the constructor's type parameters. Note that \_ indicates the wildcard parameters. 
 
~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\typ} \\
       % \prim \env = \insertTypVars {\param_1, \ldots, \param_n} \\
       \typWellFormedWithEnv {\extendTypEnv \typVars} {\typs} \\
       \isDirectionless {\dirs}}
     { \typWellFormed {\constructorTyp \typParams \prms {\typ}}}
     \quad (\constructorT)}

~ End InfRule

### Table Type { #sec-table-t }

A table type is well-formed under an environment if it exists in the environment.

- $\lookupTypEnv \name $ Looks up $\name$ from the type environment $\typEnv$ and returns the type assigned to it.

~ Begin InfRule

  \inferrule
     { \lookupTypEnv \name = \whatevs}
     { \typWellFormed {\tableTyp \name} }
     \quad (\tableT)

~ End InfRule

### Reference Type { #sec-typename-t }

The rule $\typeNameT$ states that the type name $\name$ is well-formed under the environment $\env$ if it exists in the environment.

~ Begin InfRule

  \inferrule
     { \lookupTypEnv \typVar = \whatevs}
     { \typWellFormed {\typVar} }
     \quad (\typeNameT)

~ End InfRule

## Type Equality Judgment { #sec-type-eq }
```**TODO**: refer to type_equality and solve_types functions in impl. For type equality of p4 spec refer to to section 8, under each operation there's a one liner that talks about when two types are equal for the type it's covering. ```

- The [type equality judgment][#sec-type-eq] checks the equality of two types. It has
the form $\typEqEnv {\overline {(\var, \prim \var)}} {\typ_1} {\typ_2} $ which states that the types $\typ_1$ and $\typ_2$ are equivalent under the environment $\env$ with equivalent variable pairs $\overline {(\var, \prim \var)}$. Note that Alpha equivalent types are equivalent. 


## Type Unification { #sec-type-unify }

Type unification attempts to unify two expression types, that is, it attempts to come up with constraints that allow the two types to be equivalent. The constraints are just assignments of types to unknown type variables (given as $\typVars$). 

- type unification for type produces by type checking, i.e., typed.type.t
- both types are reduced first. for brevity we omit the reduction from rules. so type 1 and type 2 in rules are already reduced.

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \boolTyp \boolTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Bools})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \stringTyp \stringTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Strings})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \integerTyp \integerTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Integers})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \errTyp \errTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Errors})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \matchKindTyp \matchKindTyp {\overline {\typVar : \bot}}}
     \quad (\rn{MatchKinds})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \voidTyp \voidTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Voids})}

~ End InfRule


~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Specializeds})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{TypeNames})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{NewTypes})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{FixedLengths})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Arrays})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Tuples})}

~ End InfRule

~ Begin InfRule

% check which one of record, header, header union, struct you used in well-formedness.
  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Records})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Sets})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Enums})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Packages})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Controls})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Parsers})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Externs})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Actions})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Functions})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Constructors})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Tables})}

~ End InfRule

``TODO: check see if you need implicit casting incorporated in unification of types.``

# Expression's Typing Rules { #sec-exp-typing }

# Statement's Typing Rules { #sec-stmt-typing }


# Declaration's Typing Rules { #sec-decl-typing }

# References    { #sec-references }

~ Bibliography { caption:"00" }
~~Bibitem {#harper-types-PL}
Robert Harper.
Types and Programming Languages.
<http://www.cs.cmu.edu/~rwh/courses/typesys/>
~~
~~Bibitem {#wiki-type-sys}
Type System.
<https://en.wikipedia.org/wiki/Type_system>
~~
~

# Appendix: Programming Languages Terminology { #sec-terminology; @h1:"A" }

## A Developer's Guide to Reading Inference Rules { #sec-guide }


# Appendix: Petr4 { #sec-petr4 }

## Petr4's Architecture { #sec-arch }


## Petr4's Type System { #sec-petr4-type-sys }


## Connecting Formalization to Petr4's Implementation { #sec-conn }



