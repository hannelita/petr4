
(datatype TST
  (FALSE)
  (TRUE)
  (EQ i64 String)
  (NOT TST)
  (OR TST TST)
  (AND TST TST))

(datatype CMD
  (SET i64 String)
  (ASSERT TST)
  (IF TST CMD CMD)
  (SEQ CMD CMD)
  (SKIP))

; axiom U1
(rewrite (IF b e e) e)
; XXX no reverse rule

; axiom U2
(birewrite (IF b e f) (IF (NOT b) f e))

; axiom U3
(birewrite
  (IF c (IF b e f) g)
  (IF (AND b c) e (IF c f g)))

; axiom U4
(birewrite (IF b e f)
         (IF b (SEQ (ASSERT b) e) f))
; axiom U5
(birewrite (SEQ (IF b e f) g)
         (IF b (SEQ e g) (SEQ f g)))
; axiom S1
(birewrite (SEQ (SEQ e f) g) (SEQ e (SEQ f g)))
; axiom S2
(rewrite (SEQ (ASSERT FALSE) x) (ASSERT FALSE))
; XXX no reverse rule: would have to cook up a value for x from nothing.
; axiom S3
(rewrite (SEQ x (ASSERT FALSE)) (ASSERT FALSE))
; XXX no reverse rule: would have to cook up a value for x from nothing.
; axiom S4
(rewrite (SEQ SKIP x) x)
;(rewrite x (SEQ SKIP x))
; axiom S5
(rewrite (SEQ x SKIP) x)
;(rewrite x (SEQ x SKIP))
; axiom S6
(rewrite (SEQ (ASSERT b) (ASSERT c)) (ASSERT (AND b c)))

; set and test rules
(rewrite (SEQ (SET x e) (IF (EQ x e) t f))
                   (SEQ (SET x e) t))
(rewrite (SEQ (SET x e1) (IF (EQ x e2) t f))
         (SEQ (SET x e1) f)
         :when ((!= e1 e2)))

(push)
(define e0
  (SEQ
    (IF (EQ 0 "10.0.0.1")
        (SET 1 "aa:bb:cc:dd:ee:ff")
        (SET 1 "aa:aa:aa:aa:aa:aa"))
    (IF (EQ 1 "aa:bb:cc:dd:ee:ff")
        (SET 2 "1")
        (SET 2 "2"))))
(run 5)
(extract e0)
(pop)

(push)
(define e1
  (SEQ
     (IF (EQ 0 "10.0.0.1")
         (SET 1 "A")
         (IF (EQ 0 "10.0.0.2")
             (SET 1 "B")
             (SET 1 "F")))
     (IF (EQ 1 "A")
         (SET 2 "1")
         (SET 2 "2"))))
(run 5)
(extract e1)
(pop)

